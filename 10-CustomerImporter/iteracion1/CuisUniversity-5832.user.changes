

----QUIT----(30 May 2023 00:05:32) CuisUniversity-5832.image priorSource: 4928100!

----STARTUP---- (30 May 2023 00:05:33) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5832.image!


----QUIT----(30 May 2023 00:05:33) CuisUniversity-5832.image priorSource: 9366537!

----STARTUP---- (6 June 2023 13:05:16) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


TestCase subclass: #ShoppingCartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

!classDefinition: #ShoppingCartTest category: 'TusLibros01' stamp: 'JB 6/6/2023 13:05:50'!
TestCase subclass: #ShoppingCartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

!classDefinition: #ShoppingCart category: 'TusLibros01' stamp: 'JB 6/6/2023 13:07:14'!
Object subclass: #ShoppingCart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!
!ShoppingCartTest methodsFor: 'nil' stamp: 'JB 6/6/2023 13:07:10'!
test01CreatingAShopingCartShouldBeEmpty
	self  assert:  ShoppingCart new isEmpty! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:07:18'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:07:26'!
isEmpty
	self shouldBeImplemented.! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:07:37' prior: 50624396!
isEmpty
	^true! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:07:39'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:07:39'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:08:54'!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := ShoppingCart new. 
	cart add: #Book. 	
	self  deny:  ShoppingCart new isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:08:55'!
ERROR!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:10:17' prior: 50624410!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := ShoppingCart new. 
	cart add: #Book  quantity: 1. 	
	self  deny:  ShoppingCart new isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:10:20'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:10:25'!
add: aRenameMe1 quantity: aRenameMe2 
	self shouldBeImplemented.! !

!classDefinition: #ShoppingCart category: 'TusLibros01' stamp: 'JB 6/6/2023 13:10:48'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'book'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:10:46' prior: 50624433!
add: aBook quantity: aQuantity 
	book := aBook ! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:10:50'!
FAILURE!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:11:07' prior: 50624422!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := ShoppingCart new. 
	cart add: #Book  quantity: 1. 	
	self  deny:  cart isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:11:08'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:11:54' prior: 50624400!
isEmpty

	book  ifNil:  [
			^true		
		].
	^false
! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:11:55'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:11:55'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:13:31'!
test03anEmptyShoppingCartShouldListAnEmptyList

	self  assert:  OrderedCollection  new equals: ShoppingCart new list! !

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:13:34'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:13:41'!
list
	self shouldBeImplemented.! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:13:52' prior: 50624487!
list
	^OrderedCollection new! !

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:13:54'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:13:54'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:13:54'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:13:54'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:14:56'!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:14:58'!
FAILURE!

!classDefinition: #ShoppingCart category: 'TusLibros01' stamp: 'JB 6/6/2023 13:15:31'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'book books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:15:30' prior: 50624491!
list
	^books! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:15:54' overrides: 16920235!
initialize
	books :=  OrderedCollection new. ! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:16:13' prior: 50624445!
add: aBook quantity: aQuantity 
	books add: aBook ! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:16:27' prior: 50624465!
isEmpty

	^books isEmpty ! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:16:40'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:16:41'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:16:41'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:16:41'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:18:27'!
test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:18:28'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:19:04'!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!methodRemoval: ShoppingCartTest #test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:19:04'!
test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:23:02'!
test06addingABookOfAnotherEditorialShouldRaiseAnError
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:23:05'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:30:06' prior: 50624622!
test06addingABookOfAnotherEditorialShouldRaiseAnError
|cart|
	cart := ShoppingCart new. 
	self should: [
		cart add: #ElCapital  quantity: 1. 	
		]
	
	 raise: Error
	withExceptionDo: [:anError |
		self assert: anError messageText  equals: ShoppingCart  bookFromAnotherEditorialErrorMessage
		
		]
	
	
		! !

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:30:08'!
FAILURE!
!ShoppingCart class methodsFor: 'no messages' stamp: 'JB 6/6/2023 13:30:44'!
bookFromAnotherEditorialErrorMessage
	^'mmhmh ' ! !

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:30:58'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:32:48' prior: 50624539!
add: aBook quantity: aQuantity 	 
	books add: aBook ! !

!methodRemoval: ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:32:55'!
test06addingABookOfAnotherEditorialShouldRaiseAnError
|cart|
	cart := ShoppingCart new. 
	self should: [
		cart add: #ElCapital  quantity: 1. 	
		]
	
	 raise: Error
	withExceptionDo: [:anError |
		self assert: anError messageText  equals: ShoppingCart  bookFromAnotherEditorialErrorMessage
		
		]
	
	
		!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:35:17'!
test06addingABookWithAnNegativeQuantityShouldRaisAnError
|cart|
	cart := ShoppingCart new. 
	
	self  should:[
		cart add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !
!ShoppingCart class methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:35:43'!
negativeQuantityErrorMessage
	^'No se puede poner cantidades negativas' ! !

!methodRemoval: ShoppingCart class #bookFromAnotherEditorialErrorMessage stamp: 'JB 6/6/2023 13:35:45'!
bookFromAnotherEditorialErrorMessage
	^'mmhmh ' !

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:35:52'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:38:29' prior: 50624685!
add: aBook quantity: aQuantity 	
	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]. 
 
	books add: aBook ! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:38:35'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:45:03'!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := ShoppingCart new. 
	cart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:45:04'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:45:51' prior: 50624730!
add: aBook quantity: aQuantity 	
	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]. 
	1 to: aQuantity do: [
			books add: aBook 		
		]  


! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:45:53'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:46:24' prior: 50624806!
add: aBook quantity: aQuantity 	
	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:46:25'!
PASSED!
!ShoppingCart class methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:46:56'!
zeroQuantityErrorMessage
	^'No se puede poner cantidades nulas' ! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00'!
creatEmptyCart

	^ ShoppingCart new! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624477!
test03anEmptyShoppingCartShouldListAnEmptyList

	self  assert:  OrderedCollection  new equals: self creatEmptyCart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624790!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self creatEmptyCart. 
	cart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624387!
test01CreatingAShopingCartShouldBeEmpty
	self  assert:  self creatEmptyCart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624454!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := self creatEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  deny:  cart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624598!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self creatEmptyCart. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624703!
test06addingABookWithAnNegativeQuantityShouldRaisAnError
|cart|
	cart := self creatEmptyCart. 
	
	self  should:[
		cart add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624509!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self creatEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25'!
createEmptyCart

	^ ShoppingCart new! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624910!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self createEmptyCart. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624902!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := self createEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  deny:  cart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624922!
test06addingABookWithAnNegativeQuantityShouldRaisAnError
|cart|
	cart := self createEmptyCart. 
	
	self  should:[
		cart add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624935!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self createEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624896!
test01CreatingAShopingCartShouldBeEmpty
	self  assert:  self createEmptyCart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624877!
test03anEmptyShoppingCartShouldListAnEmptyList

	self  assert:  OrderedCollection  new equals: self createEmptyCart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624884!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self createEmptyCart. 
	cart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !

!methodRemoval: ShoppingCartTest #creatEmptyCart stamp: 'JB 6/6/2023 13:51:25'!
creatEmptyCart

	^ ShoppingCart new!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:52:48' prior: 50624982!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self createEmptyCart  add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:52:49'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:13'!
createACartWithASingleBook

	^ self createEmptyCart  add: #Book  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:14' prior: 50625020!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self createACartWithASingleBook. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:53:18'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:28' prior: 50624961!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := self createACartWithASingleBook 
	self  deny:  cart isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:34'!
ERROR!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:50' prior: 50625108!
test02AShoppingCartWithABookShouldNotBeEmpty

	self  deny:   self createACartWithASingleBook   isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:53:51'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:54:09' prior: 50625067!
test04AShoppingCartWithABookShouldListACollectionWithABook

	self  assert:   (OrderedCollection with: #Book) equals: self createACartWithASingleBook  list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:54:10'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:54:39' prior: 50624969!
test06addingABookWithAnNegativeQuantityShouldRaisAnError

	self  should:[
		self createEmptyCart  add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

	^ self createEmptyCart  add: #Twilight  quantity: 1!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:55:57' prior: 50625061!
createACartWithASingleBook

	^ self createEmptyCart  add: #Twilight  quantity: 1! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:55:59'!
FAILURE!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:55:59'!
FAILURE!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:56:10' prior: 50625157!
test04AShoppingCartWithABookShouldListACollectionWithABook

	self  assert:   (OrderedCollection with: #Twilight) equals: self createACartWithASingleBook  list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:56:11'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:56:43' prior: 50624949!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self createACartWithASingleBook add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:56:44'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:57:00'!
createACartWithTwoBooks

	^ self createACartWithASingleBook add: #FullMoon  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:57:00' prior: 50625294!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self createACartWithTwoBooks. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:57:14' prior: 50625342!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook

	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals:  self createACartWithTwoBooks list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:25'!
createACartWithTwilightAndFullMoon

	^ self createACartWithASingleBook add: #FullMoon  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:25' prior: 50625352!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook

	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals:  self createACartWithTwilightAndFullMoon list! !

!methodRemoval: ShoppingCartTest #createACartWithTwoBooks stamp: 'JB 6/6/2023 13:58:25'!
createACartWithTwoBooks

	^ self createACartWithASingleBook add: #FullMoon  quantity: 1!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51'!
createACartWithASingleBookNamedTwilight

	^ self createEmptyCart  add: #Twilight  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51' prior: 50625281!
test04AShoppingCartWithABookShouldListACollectionWithABook

	self  assert:   (OrderedCollection with: #Twilight) equals: self createACartWithASingleBookNamedTwilight  list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51' prior: 50625361!
createACartWithTwilightAndFullMoon

	^ self createACartWithASingleBookNamedTwilight add: #FullMoon  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51' prior: 50625119!
test02AShoppingCartWithABookShouldNotBeEmpty

	self  deny:   self createACartWithASingleBookNamedTwilight   isEmpty! !

!methodRemoval: ShoppingCartTest #createACartWithASingleBook stamp: 'JB 6/6/2023 13:58:51'!
createACartWithASingleBook

	^ self createEmptyCart  add: #Twilight  quantity: 1!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:59:30' prior: 50625005!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self createEmptyCart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:59:31'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:59:32'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:59:59'!
createACartWithTwilightTwice

	^ self createEmptyCart add:  #Twilight  quantity: 	 	2! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:00:00' prior: 50625419!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self createACartWithTwilightTwice. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:00:19' prior: 50625468!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList

	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: self createACartWithTwilightTwice  list ! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 14:00:21'!
PASSED!
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:03:54'!
checkIfTheQuantittyIsPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]! !
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:03:55' prior: 50624822!
add: aBook quantity: aQuantity 	
	self checkIfTheQuantittyIsPositive: aQuantity. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:04:34'!
raiseAnErrorIfTheQuantityIsNonPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]! !
!ShoppingCart methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:04:34' prior: 50625531!
add: aBook quantity: aQuantity 	
	self raiseAnErrorIfTheQuantityIsNonPositive: aQuantity. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !

!methodRemoval: ShoppingCart #checkIfTheQuantittyIsPositive: stamp: 'JB 6/6/2023 14:04:34'!
checkIfTheQuantittyIsPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]!
!ShoppingCart methodsFor: 'adding private' stamp: 'JB 6/6/2023 14:06:13'!
assertCanAdd: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]! !
!ShoppingCart methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:06:13' prior: 50625550!
add: aBook quantity: aQuantity 	
	self assertCanAdd: aQuantity. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !

!methodRemoval: ShoppingCart #raiseAnErrorIfTheQuantityIsNonPositive: stamp: 'JB 6/6/2023 14:06:13'!
raiseAnErrorIfTheQuantityIsNonPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]!
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:08:45'!
addBookToTheShoppingCart: aBook   thisAmountOfTimes: aQuantity 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:09:07' prior: 50625578!
add: aBook quantity: aQuantity 	
	self assertCanAdd: aQuantity. 
	self addBookToTheShoppingCart:  aBook  thisAmountOfTimes: aQuantity 

! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

----QUIT----(6 June 2023 14:09:25) CuisUniversity-5832.image priorSource: 9366758!

----STARTUP---- (6 June 2023 14:09:36) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


----QUIT----(6 June 2023 14:15:39) CuisUniversity-5832.image priorSource: 9407583!

----STARTUP---- (10 June 2023 15:15:00) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


!classRemoval: #ShoppingCart stamp: 'JB 6/10/2023 15:15:37'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'book books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

!classRemoval: #ShoppingCartTest stamp: 'JB 6/10/2023 15:15:38'!
TestCase subclass: #ShoppingCartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

----End fileIn of C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\TusLibros.st----!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:16:48'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:16:48'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:16:48'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:16:48'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:18:32' prior: 50625781!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		InstanceFactory  checkoutWitCreditCard:  InstanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:18:33'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:18:58' prior: 50626119!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		InstanceFactory cashierWithEmptyCart   checkoutWitCreditCard:  InstanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:18:58'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:20:30' prior: 50625794!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := InstanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:21:42' prior: 50625804!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := InstanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 500002 with:  1 ) equals:  bookOfSells! !

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:21:47'!
ERROR!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:22:15'!
ERROR!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:22:35'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:22:35'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:22:35'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:22:35'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:22:38'!
ERROR!

aCreditCard!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:23:33' prior: 50626097!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September ). ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:23:51' prior: 50626051!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:24:01' prior: 50626230!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2014 month: September ). ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:24:03'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:24:03'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:24:07'!
ERROR!

aCreditCard!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:24:37' prior: 50626246!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2024 month: September ). ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:24:39'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:24:39'!
ERROR!

todayDate!
!InstanceFactory class methodsFor: 'category-name' stamp: 'lp 6/8/2023 21:41:17' prior: 50626237!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 3000   month: July ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:26:36' prior: 50626067!
cashierWithEmptyCart
	^Cashier for: self  createEmptyCart ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:26:44' prior: 50626346!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:26:48' prior: 50626355!
cashierWithEmptyCart
	^Cashier for: self  createEmptyCart dated: (GregorianMonthOfYear year: 3000   month: July ). 
 ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:26:50'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:26:50'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:26:50'!
ERROR!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:27:32' prior: 50626361!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 3000   month: July ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:27:48' prior: 50626059!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^Cashier for: cart dated: (GregorianMonthOfYear year: 3000   month: July ). 
 
 ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:27:49'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:27:49'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:27:52'!
ERROR!

todayDate!

aCreditCard!

aCreditCard date!

todayDate!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:26' prior: 50626424!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^Cashier for: cart dated: (GregorianMonthOfYear year: 2023   month: July ). 
 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:29' prior: 50626479!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^Cashier for: cart dated: (GregorianMonthOfYear year: 2023   month: June ). 
 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:35' prior: 50626415!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: July ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:43' prior: 50626499!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:52' prior: 50626368!
cashierWithEmptyCart
	^Cashier for: self  createEmptyCart dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:29:31'!
createCashierDatadForTheCart

	^ Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June )! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:29:31' prior: 50626508!
cashierWithACartWithABook
		^self createCashierDatadForTheCart. 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:43' prior: 50626533!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:30:21'!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!methodRemoval: InstanceFactory class #createCashierDatadForTheCart stamp: 'JB 6/10/2023 15:30:22'!
createCashierDatadForTheCart

	^ Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June )!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:30:37' prior: 50626547!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:31:02' prior: 50626539!
cashierWithACartWithABook
		
 ^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:31:03'!
FAILURE!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:31:03'!
FAILURE!

bookOfSells!
!Cashier methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:33:05' prior: 50625940!
checkoutWitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		bookOfSells  add: ammount .
		].
	
	
	^ammount 
	
	! !

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:33:08'!
FAILURE!

bookOfSells!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:33:38' prior: 50626189!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := InstanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:33:40'!
PASSED!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:33:59' prior: 50626489!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self createCashierDatadForTheCart:  cart
 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:34:21' prior: 50626517!
cashierWithEmptyCart
	^self createCashierDatadForTheCart:  self createEmptyCart ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:34:23'!
PASSED!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:34:31' prior: 50626572!
cashierWithACartWithABook
		^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:34:33' prior: 50626715!
cashierWithACartWithABook
	^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:34:34'!
PASSED!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:35:44'!
cashierWithACartWithABook
	^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !

!methodRemoval: InstanceFactory class #cashierWithACartWithABook stamp: 'JB 6/10/2023 15:35:45'!
cashierWithACartWithABook
	^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:35:53'!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self createCashierDatadForTheCart:  cart
 
 ! !

!methodRemoval: InstanceFactory class #cashierWithACartWithTwoBooks stamp: 'JB 6/10/2023 15:35:53'!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self createCashierDatadForTheCart:  cart
 
 !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:35:58'!
cashierWithEmptyCart
	^self createCashierDatadForTheCart:  self createEmptyCart ! !

!methodRemoval: InstanceFactory class #cashierWithEmptyCart stamp: 'JB 6/10/2023 15:35:58'!
cashierWithEmptyCart
	^self createCashierDatadForTheCart:  self createEmptyCart !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:03'!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!methodRemoval: InstanceFactory class #createCashierDatadForTheCart: stamp: 'JB 6/10/2023 15:36:03'!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:07'!
createEmptyCart
	^Cart acceptingItemsOf: self defaultCatalog! !

!methodRemoval: InstanceFactory class #createEmptyCart stamp: 'JB 6/10/2023 15:36:07'!
createEmptyCart
	^Cart acceptingItemsOf: self defaultCatalog!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:10'!
defaultCatalog
	|catalog| 
	catalog := Dictionary  new. 
	catalog add:( Association  key:  self itemSellByTheStore  value:  500002). 
	catalog add:( Association  key:  'Full Moon'   value:  1). 

	^ catalog! !

!methodRemoval: InstanceFactory class #defaultCatalog stamp: 'JB 6/10/2023 15:36:10'!
defaultCatalog
	|catalog| 
	catalog := Dictionary  new. 
	catalog add:( Association  key:  self itemSellByTheStore  value:  500002). 
	catalog add:( Association  key:  'Full Moon'   value:  1). 

	^ catalog!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:15'!
expiredCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September ). ! !

!methodRemoval: InstanceFactory class #expiredCreditCard stamp: 'JB 6/10/2023 15:36:15'!
expiredCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September ). !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:18'!
itemSellByTheStore
	^ 'validBook'! !

!methodRemoval: InstanceFactory class #itemSellByTheStore stamp: 'JB 6/10/2023 15:36:18'!
itemSellByTheStore
	^ 'validBook'!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:22'!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2024 month: September ). ! !

!methodRemoval: InstanceFactory class #validCreditCard stamp: 'JB 6/10/2023 15:36:23'!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2024 month: September ). !

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'JB 6/10/2023 15:36:43'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:42' prior: 50626139!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWitCreditCard:  InstanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:51' prior: 50626174!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:54' prior: 50626910!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:59' prior: 50626893!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:02' prior: 50626640!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := InstanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:04' prior: 50626957!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:09' prior: 50625814!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := InstanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:11' prior: 50626989!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:32' prior: 50627008!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:51' overrides: 16961394!
setUp
	instanceFactory := InstanceFactory  new.
	! !

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:37:52'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:37:52'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:37:52'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:37:52'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:40:34'!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!Cashier methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:41:34'!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		bookOfSells  add: ammount .
		].
	
	
	^ammount 
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50626940!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50627065!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50626973!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50627027!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50626925!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !

!methodRemoval: Cashier #checkoutWitCreditCard:registerOn: stamp: 'JB 6/10/2023 15:41:34'!
checkoutWitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		bookOfSells  add: ammount .
		].
	
	
	^ammount 
	
	!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:41:36'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:43:44'!
test07robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierTest #test07robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test07robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:44:00'!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!methodRemoval: CashierTest #test07robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:44:00'!
test07robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	!

!methodRemoval: Cashier #checkoutWitCreditCard: stamp: 'JB 6/10/2023 17:12:49'!
checkoutWitCreditCard: aCreditCard
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		].
	^ammount 
	
	
	!

!classRenamed: #Cashier as: #CashierForSell stamp: 'JB 6/10/2023 17:15:10'!
Smalltalk renameClassNamed: #Cashier as: #CashierForSell!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627114!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSell cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627257!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSell cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627149!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSell cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627097!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSell cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50626810!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSell for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!classRenamed: #CashierForSell as: #CashierForSale stamp: 'JB 6/10/2023 17:15:34'!
Smalltalk renameClassNamed: #CashierForSell as: #CashierForSale!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:34' prior: 50627309!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:34' prior: 50627329!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:35' prior: 50627348!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:35' prior: 50627367!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:35' prior: 50627385!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!classRenamed: #CashierTest as: #CashierForSaleTest stamp: 'JB 6/10/2023 17:15:46'!
Smalltalk renameClassNamed: #CashierTest as: #CashierForSaleTest!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:15:47'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 17:16:21'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:16:36' prior: 50627133!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection  with:  500003 ) equals:  bookOfSells! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:16:57' prior: 50627084!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
	
		].
	
		bookOfSells  add: ammount .
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:17:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:17:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:17:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:17:03'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:17:03'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:17:03'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:18:00'!
test05creditCardWithoutFundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!methodRemoval: CashierForSaleTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:00'!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:18:15'!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!methodRemoval: CashierForSaleTest #test05creditCardWithoutFundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:15'!
test05creditCardWithoutFundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:18'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:19:02' prior: 50627634!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:23:06' prior: 50627701!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 	
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!classDefinition: #MerchantProcessorSimulator category: 'TusLibros' stamp: 'JB 6/10/2023 17:30:11'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:30:05' prior: 50627474!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June ) merchantProcessor: MerchantProcessorSimulator new.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 17:30:17'!
ERROR!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:31:13'!
ERROR!
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:31:25'!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator ! !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:31:44' prior: 50627835!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:31:46'!
ERROR!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 17:32:03'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 17:32:03'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear merchantProcessorSimulator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:32:03'!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	self shouldBeImplemented.
	cart := aCart.
	gregorianMonthOfYear := aGregorianMonthOfYear.
	merchantProcessorSimulator := aMerchantProcessorSimulator.! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:32:17' prior: 50627878!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	gregorianMonthOfYear := aGregorianMonthOfYear.
	merchantProcessorSimulator := aMerchantProcessorSimulator.! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:32:19'!
ERROR!

todayDate!

!methodRemoval: CashierForSale #initializeFor: stamp: 'JB 6/10/2023 17:32:58'!
initializeFor: aCart 

	cart := aCart.!

!methodRemoval: CashierForSale #initializeFor:dated: stamp: 'JB 6/10/2023 17:33:01'!
initializeFor: aCart dated: aDate 
	
	cart := aCart.
	 todayDate  := aDate.!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:33:13' prior: 50627889!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aGregorianMonthOfYear.
	merchantProcessorSimulator := aMerchantProcessorSimulator.! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!methodRemoval: CashierForSale class #for: stamp: 'JB 6/10/2023 17:33:21'!
for: aCart 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"

	^self new initializeFor: aCart !

!methodRemoval: CashierForSale class #for:dated: stamp: 'JB 6/10/2023 17:33:23'!
for: aCart dated: adate 

	^self new initializeFor: aCart dated: adate !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:39'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:34:05'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:34:11'!
PASSED!

cashier!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:35:38' prior: 50627721!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		self fail.
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:35:57' prior: 50627995!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		self error.
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:36:05' prior: 50628069!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:06'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:06'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:06'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:36:17' prior: 50628143!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		] raise: Error
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:40:11' prior: 50627532!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
			
		].
	bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		]
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:14'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:20'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:40:25'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:40:25'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:40:28'!
ERROR!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:40:38' prior: 50628236!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
			
		].
	bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:40:40'!
ERROR!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:40:51'!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	self shouldBeImplemented.! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:41:06' prior: 50628309!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	^true! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:41:08'!
FAILURE!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:41:17'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:42:06'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:43:36' prior: 50628190!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard   registerOn: bookOfSells . 
		] raise: Error
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:38'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:38'!
ERROR!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:43:56' prior: 50628353!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardWithoutFunds   registerOn: bookOfSells . 
		] raise: Error
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:03'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:03'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:44:47' prior: 50628380!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardWithoutFunds   registerOn: bookOfSells . 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:48'!
ERROR!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:45:04'!
creditCardWithoutFunds
	self shouldBeImplemented.! !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:48:24' prior: 50628504!
creditCardWithoutFunds
	^CreditCard  number: 1   date:  (GregorianMonthOfYear  month:  September  year: 2024) name: 'Lionel Messi' ! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:48:31'!
ERROR!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:49:38' prior: 50628509!
creditCardWithoutFunds
	^CreditCard  number: 1   date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Lionel Messi' ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
ERROR!
!CreditCard class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:50:05'!
number: aSmallInteger date: aGregorianMonthOfYear name: aString 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeNumber: aSmallInteger date: aGregorianMonthOfYear name: aString ! !
!CreditCard class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:51:00' prior: 50628555!
number: creditCardNumber date: expirationDate name: creditCardOwner 
	
	^self new initializeNumber: creditCardNumber date: expirationDate name: creditCardOwner ! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:51:01'!
ERROR!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:09'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:09'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber_CHANGE_ME expirationDate_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:09'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber_CHANGE_ME expirationDate_CHANGE_ME creditCardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:09'!
initializeNumber: creditCardNumber date: expirationDate name: creditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := creditCardNumber.
	expirationDate_CHANGE_ME := expirationDate.
	creditCardOwner_CHANGE_ME := creditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:22' prior: 50628605!
initializeNumber: aCreditCardNumber date: expirationDate name: creditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := aCreditCardNumber.
	expirationDate_CHANGE_ME := expirationDate.
	creditCardOwner_CHANGE_ME := creditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:29' prior: 50628616!
initializeNumber: aCreditCardNumber date: anExpirationDate name: creditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := aCreditCardNumber.
	expirationDate_CHANGE_ME := anExpirationDate.
	creditCardOwner_CHANGE_ME := creditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:35' prior: 50628627!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := aCreditCardNumber.
	expirationDate_CHANGE_ME := anExpirationDate.
	creditCardOwner_CHANGE_ME := aCreditCardOwner.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:43'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate_CHANGE_ME creditCardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:51:43' prior: 50628638!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber := aCreditCardNumber.
	expirationDate_CHANGE_ME := anExpirationDate.
	creditCardOwner_CHANGE_ME := aCreditCardOwner.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:49'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate creditCardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:51:49' prior: 50628659!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber := aCreditCardNumber.
	expirationDate := anExpirationDate.
	creditCardOwner_CHANGE_ME := aCreditCardOwner.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:55'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate creditCardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:51:55' prior: 50628679!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber := aCreditCardNumber.
	expirationDate := anExpirationDate.
	creditCardOwner := aCreditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:52:00' prior: 50628699!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	creditCardNumber := aCreditCardNumber.
	expirationDate := anExpirationDate.
	creditCardOwner := aCreditCardOwner.! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:52:03'!
ERROR!

aCreditCard!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:53:38'!
createLionelMessiCreditCardDated

	^ CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September )! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:53:39' prior: 50626854!
expiredCreditCard
	^self createLionelMessiCreditCardDated. ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:54:15'!
createLionelMessiCreditCardDated: aDate

	^ CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September )! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:54:16' prior: 50628730!
expiredCreditCard
	^self createLionelMessiCreditCardDated: dated. ! !

!methodRemoval: InstanceFactory #createLionelMessiCreditCardDated stamp: 'JB 6/10/2023 17:54:16'!
createLionelMessiCreditCardDated

	^ CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September )!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:54:52' prior: 50628742!
expiredCreditCard
	^self createLionelMessiCreditCardDated: ( GregorianMonthOfYear year:  2010 month: September ). ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:55:15' prior: 50626874!
validCreditCard
	^self createLionelMessiCreditCardDated:   ( GregorianMonthOfYear year:  2024 month: September ). ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:55:44' prior: 50628735!
createLionelMessiCreditCardDated: aDate

	^ CreditCard  number: 1   date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Lionel Messi' ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:55:55' prior: 50628768!
createLionelMessiCreditCardDated: aDate

	^ CreditCard  number: 1   date:  aDate name: 'Lionel Messi' ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:57:44'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:57:47'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:58:10'!
ERROR!
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:58:35' prior: 50626010!
date
	
	^expirationDate ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:58:40'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
ERROR!

!methodRemoval: CreditCard #initializeDate: stamp: 'JB 6/10/2023 17:59:22'!
initializeDate: aGregorianMonthOfYear 

date := aGregorianMonthOfYear.!

!methodRemoval: CreditCard class #date: stamp: 'JB 6/10/2023 17:59:41'!
date: aGregorianMonthOfYear 

	^self new initializeDate: aGregorianMonthOfYear !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
ERROR!

!classDefinition: #MerchantProcessorSimulator category: 'TusLibros' stamp: 'JB 6/10/2023 18:09:02'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: 'creditCardWithoutFunds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #MerchantProcessorSimulator category: 'TusLibros' stamp: 'JB 6/10/2023 18:09:08'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: 'creditCardWithoutFunds stolenCreditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:08:58' prior: 50628316!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard = creditCardWithoutFunds )ifTrue:[
				self error: self class creditCardWithoutFunds 
			] ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCard 
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:09:33' prior: 50628906!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard = creditCardWithoutFunds )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			] ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCardErrorMessage 
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:10:04' prior: 50628919!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard = creditCardWithoutFunds )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			] "ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCardErrorMessage 
				] 
			]"
		! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:10:32'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:10:32'!
ERROR!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:15:32' prior: 50628288!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
			
		].
	bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:19:20' prior: 50628481!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardWithoutFunds   registerOn: bookOfSells . 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: MerchantProcessorSimulator creditCardWithoutFundsErrorMessage.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:19:24'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:19:24'!
ERROR!

aCreditCard!

creditCardWithoutFunds!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:21:00' overrides: 16920235!
initialize
	creditCardWithoutFunds  := InstanceFactory  new creditCardWithoutFunds ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:03'!
ERROR!

creditCardWithoutFunds!

creditCardWithoutFunds!

aCreditCard = creditCardWithoutFunds !

aCreditCard!

creditCardWithoutFunds!

creditCardWithoutFunds!

aCreditCard!

self!

anObject!

self == anObject!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:24:37' prior: 50628933!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			] "ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCardErrorMessage 
				] 
			]"
		! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:24:39'!
ERROR!
!CreditCard methodsFor: 'number' stamp: 'JB 6/10/2023 18:24:52'!
number
	self shouldBeImplemented.! !
!CreditCard methodsFor: 'number' stamp: 'JB 6/10/2023 18:25:05' prior: 50629062!
number
	^creditCardNumber ! !

aCreditCard  number = creditCardWithoutFunds number!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:25:23'!
ERROR!
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:25:30'!
creditCardWithoutFundsErrorMessage
	self shouldBeImplemented.! !
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:26:31' prior: 50629076!
creditCardWithoutFundsErrorMessage
	^'no tiene fondos la tarjeta :)' ! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:35'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:26:40'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:26:40'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:26:40'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:40'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:40'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:40'!
PASSED!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 18:27:42' prior: 50628521!
creditCardWithoutFunds
	^CreditCard  number:    2 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Cristiano Ronaldo' ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:28'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:29:46' prior: 50627418!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale canNotRefactorWithIncompleteTypeInfo.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:30:12' prior: 50629217!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSaleForRobedCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 18:31:56'!
createRobbedCard
	^CreditCard  number:    3 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Robben Van Persy' ! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:33:52' prior: 50629045!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:34:59' prior: 50629001 overrides: 16920235!
initialize
	|instanceFactory |
	instanceFactory := 	InstanceFactory  new. 
	creditCardWithoutFunds  :=  instanceFactory  creditCardWithoutFunds.
	stolenCreditCard := instanceFactory  createRobbedCard. ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 18:35:17'!
creditCardRobbed
	^CreditCard  number:    3 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Robben Van Persy' ! !
!MerchantProcessorSimulator methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:35:18' prior: 50629279 overrides: 16920235!
initialize
	|instanceFactory |
	instanceFactory := 	InstanceFactory  new. 
	creditCardWithoutFunds  :=  instanceFactory  creditCardWithoutFunds.
	stolenCreditCard := instanceFactory  creditCardRobbed. ! !

!methodRemoval: InstanceFactory #createRobbedCard stamp: 'JB 6/10/2023 18:35:18'!
createRobbedCard
	^CreditCard  number:    3 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Robben Van Persy' !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:43'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:37:41' prior: 50629237!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardRobbed   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSaleForRobedCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:37:44'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:37:44'!
ERROR!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:38:27' prior: 50629264!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:38:32'!
ERROR!
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:38:38'!
cannotProcessSaleForRobedCreditCard
	self shouldBeImplemented.! !
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:40:24' prior: 50629386!
cannotProcessSaleForRobedCreditCard
	^'tarjeta robada error message' ! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:40:30'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:43:43' prior: 50629341!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardRobbed   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:54:15' prior: 50628954!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list inject:  ammount  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	
		bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:54:17'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:17'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:54:40' prior: 50629452!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	
		bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:42'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:54:48' prior: 50629493!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	
		bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:49'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:55:31' prior: 50629534!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:55:32'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:02'!
checkForEmptyCart

	^ cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:02' prior: 50629575!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	self checkForEmptyCart. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:26'!
calculateTotalAmmount

	^ cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		]! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:26' prior: 50629620!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	self checkForEmptyCart. 

	self checkForDate: aCreditCard.

	
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:45' prior: 50629642!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 18:57:11'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear merchantProcessorInteface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:57:11' prior: 50629655!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	merchantProcessorInteface  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:57:11' prior: 50627912!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aGregorianMonthOfYear.
	merchantProcessorInteface := aMerchantProcessorSimulator.! !

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 18:58:34'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear creditCardDebitator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:58:34' prior: 50629700!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	creditCardDebitator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:58:34' prior: 50629713!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aGregorianMonthOfYear.
	creditCardDebitator := aMerchantProcessorSimulator.! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:00:07'!
debitTheAmmount: aCreditCard toTheCreditCard: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:00:07' prior: 50629732!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	creditCardDebitator  debitTheAmmount: aCreditCard  toTheCreditCard: ammount. 
	^ammount 
	
	! !

!methodRemoval: MerchantProcessorSimulator #processPurchaseWithCreditCard:ofTheAmmount: stamp: 'JB 6/10/2023 19:00:07'!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:00:21' prior: 50629769!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	creditCardDebitator  debitTheAmmount:    ammount  toTheCreditCard: aCreditCard . 
	^ammount 
	
	! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:01:04' prior: 50629755!
debitTheAmmount: anAmmount2debit toTheCreditCard: ammount 
	(anAmmount2debit  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(anAmmount2debit  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:01:39' prior: 50629809!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:01:54'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:02:36' prior: 50629796!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	creditCardDebitator  debitTheAmmount:    ammount  toTheCreditCard: aCreditCard . 
	bookOfSells  add: ammount .
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:41'!
PASSED!
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:05:31' prior: 50625924!
checkForDate: aCreditCard 
	( todayDate >  aCreditCard date ) ifTrue:[
			self error: self class cannotProccesSellForExpiredCreditCard 
			]! !
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:06:00' prior: 50629614!
checkForEmptyCart
 cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:06:01'!
PASSED!
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:06:03' prior: 50629928!
checkForEmptyCart
	 cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]! !
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:07:25' prior: 50625952!
emptycarterrorMessage

! !
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:07:30' prior: 50629957!
checkForEmptyCart
	 cart isEmpty ifTrue:[
			 self error: self class cannotCheckoutEmptyCart	
		]! !

!methodRemoval: CashierForSale #emptycarterrorMessage stamp: 'JB 6/10/2023 19:07:32'!
emptycarterrorMessage

!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:07:43'!
PASSED!
!CashierForSale methodsFor: 'initializing' stamp: 'JB 6/10/2023 19:07:57' prior: 50629745!
initializeFor: aCart dated: aDate merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aDate.
	creditCardDebitator := aMerchantProcessorSimulator.! !
!CashierForSale methodsFor: 'initializing' stamp: 'JB 6/10/2023 19:08:13' prior: 50630000!
initializeFor: aCart dated: aDate merchantProcessor: aCreditCardDebitator 
	cart := aCart.
	todayDate := aDate.
	creditCardDebitator := aCreditCardDebitator.! !

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 19:08:25'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart date gregorianMonthOfYear creditCardDebitator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:08:25' prior: 50629920!
checkForDate: aCreditCard 
	( date >  aCreditCard date ) ifTrue:[
			self error: self class cannotProccesSellForExpiredCreditCard 
			]! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:08:25' prior: 50630009!
initializeFor: aCart dated: aDate merchantProcessor: aCreditCardDebitator 
	cart := aCart.
	date := aDate.
	creditCardDebitator := aCreditCardDebitator.! !
!CashierForSale methodsFor: 'initializing' stamp: 'JB 6/10/2023 19:08:48'!
initializeFor: aCart dated: aDate debitCreditCardWith: aCreditCardDebitator 
	cart := aCart.
	date := aDate.
	creditCardDebitator := aCreditCardDebitator.! !
!CashierForSale class methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:08:48' prior: 50627848!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear debitCreditCardWith: aMerchantProcessorSimulator ! !

!methodRemoval: CashierForSale #initializeFor:dated:merchantProcessor: stamp: 'JB 6/10/2023 19:08:48'!
initializeFor: aCart dated: aDate merchantProcessor: aCreditCardDebitator 
	cart := aCart.
	date := aDate.
	creditCardDebitator := aCreditCardDebitator.!
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:15'!
forTheShoppingCart: aCart withDate: aGregorianMonthOfYear debitSaleWithTheDebitator: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear debitCreditCardWith: aMerchantProcessorSimulator ! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:10:15' prior: 50627748!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale forTheShoppingCart: (aShoppingCart ) withDate: (GregorianMonthOfYear year: 2023   month: June ) debitSaleWithTheDebitator: MerchantProcessorSimulator new.! !

!methodRemoval: CashierForSale class #for:dated:merchantProcessor: stamp: 'JB 6/10/2023 19:10:15'!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear debitCreditCardWith: aMerchantProcessorSimulator !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:25' prior: 50630069!
forTheShoppingCart: aCart withDate: aDate debitSaleWithTheDebitator: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aDate debitCreditCardWith: aMerchantProcessorSimulator ! !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:36' prior: 50630100!
forTheShoppingCart: aCart withDate: aDate debitSaleWithTheDebitator: aCreditCardDebitator 
	^self new initializeFor: aCart dated: aDate debitCreditCardWith: aCreditCardDebitator ! !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:45' prior: 50630110!
forTheShoppingCart: aCartToCheckOut withDate: aDate debitSaleWithTheDebitator: aCreditCardDebitator 
	^self new initializeFor: aCartToCheckOut dated: aDate debitCreditCardWith: aCreditCardDebitator ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:11:25'!
xxx
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:12:23'!
xxx: aCashier
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxx stamp: 'JB 6/10/2023 19:12:23'!
xxx
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:13:00'!
xxx: aCashier creditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxx: stamp: 'JB 6/10/2023 19:13:00'!
xxx: aCashier
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:13:21'!
xxxForCashier: aCashier withCreditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxx:creditCard: stamp: 'JB 6/10/2023 19:13:22'!
xxx: aCashier creditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:13:57' prior: 50630209!
xxxForCashier: aCashier withCreditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| | aBlock_ |
		self assert:  anError messageText   equals:   aBlock_ value.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:14:52'!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| | aBlock_ |
		self assert:  anError messageText   equals:   aBlock_ value.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxxForCashier:withCreditCard: stamp: 'JB 6/10/2023 19:14:52'!
xxxForCashier: aCashier withCreditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| | aBlock_ |
		self assert:  anError messageText   equals:   aBlock_ value.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:14:57' prior: 50630260!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock value.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:15:05' prior: 50630292!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock value.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:16:24' prior: 50627456!
test01checkoutEmptyCartShouldRaiseAnError

	self xxxForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  messageError: [CashierForSale cannotCheckoutEmptyCart]! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:26'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:16:34' prior: 50630309!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:16:39' prior: 50630325!
test01checkoutEmptyCartShouldRaiseAnError

	self xxxForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  messageError: CashierForSale cannotCheckoutEmptyCart! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:40'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:17:55' prior: 50627437!
test04expiredCreditcardShouldNotProceedWithTheSell
		self xxxForCashier:  
			instanceFactory cashierWithACartWithABook
		 withCreditCard:  
			instanceFactory  expiredCreditCard
		messageError: 
			CashierForSale cannotProccesSellForExpiredCreditCard! !

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:19:09' prior: 50628971!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
		self xxxForCashier:  
			instanceFactory cashierWithACartWithABook	
		 withCreditCard:  
			instanceFactory  creditCardWithoutFunds	
		messageError: 
			MerchantProcessorSimulator creditCardWithoutFundsErrorMessage
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:11'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:11'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:11'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:20:41' prior: 50629406!
test06robedCreditCardShouldNotProceedWithTheSell 
		self xxxForCashier:  
				instanceFactory cashierWithACartWithABook		 
			withCreditCard:  
				instanceFactory  creditCardRobbed
				messageError: 
					MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard
	! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53'!
checkoutForCashier: aCashier withCreditCard: aCreditCard shouldRaiseAnErrorWithDescription: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630378!
test01checkoutEmptyCartShouldRaiseAnError

	self checkoutForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  shouldRaiseAnErrorWithDescription: CashierForSale cannotCheckoutEmptyCart! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630415!
test04expiredCreditcardShouldNotProceedWithTheSell
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook
		 withCreditCard:  
			instanceFactory  expiredCreditCard
		shouldRaiseAnErrorWithDescription: 
			CashierForSale cannotProccesSellForExpiredCreditCard! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630454!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook	
		 withCreditCard:  
			instanceFactory  creditCardWithoutFunds	
		shouldRaiseAnErrorWithDescription: 
			MerchantProcessorSimulator creditCardWithoutFundsErrorMessage
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630493!
test06robedCreditCardShouldNotProceedWithTheSell 
		self checkoutForCashier:  
				instanceFactory cashierWithACartWithABook		 
			withCreditCard:  
				instanceFactory  creditCardRobbed
				shouldRaiseAnErrorWithDescription: 
					MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard
	! !

!methodRemoval: CashierForSaleTest #xxxForCashier:withCreditCard:messageError: stamp: 'JB 6/10/2023 19:22:53'!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39'!
checkoutForCashier: aCashier withCreditCard: aCreditCard shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630560!
test04expiredCreditcardShouldNotProceedWithTheSell
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook
		 withCreditCard:  
			instanceFactory  expiredCreditCard
		shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: 
			CashierForSale cannotProccesSellForExpiredCreditCard! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630585!
test06robedCreditCardShouldNotProceedWithTheSell 
		self checkoutForCashier:  
				instanceFactory cashierWithACartWithABook		 
			withCreditCard:  
				instanceFactory  creditCardRobbed
				shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: 
					MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630572!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook	
		 withCreditCard:  
			instanceFactory  creditCardWithoutFunds	
		shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: 
			MerchantProcessorSimulator creditCardWithoutFundsErrorMessage
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630549!
test01checkoutEmptyCartShouldRaiseAnError

	self checkoutForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: CashierForSale cannotCheckoutEmptyCart! !

!methodRemoval: CashierForSaleTest #checkoutForCashier:withCreditCard:shouldRaiseAnErrorWithDescription: stamp: 'JB 6/10/2023 19:24:39'!
checkoutForCashier: aCashier withCreditCard: aCreditCard shouldRaiseAnErrorWithDescription: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:27:51' prior: 50627168!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:27:57' prior: 50630702!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:27:58'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:28:30' prior: 50627517!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection  with:  ammount ) equals:  bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:28:58' prior: 50630761!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: OrderedCollection new ).
	self assert: (OrderedCollection  with:  ammount ) equals:  bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:29:05' prior: 50630718!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: OrderedCollection new ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:28:30' prior: 50630778!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection  with:  ammount ) equals:  bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:27:57' prior: 50630795!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:10'!
m1: cashier m2: bookOfSells m3: ammount

	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:10' prior: 50630829!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self m1: cashier m2: bookOfSells m3: ammount ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:33' prior: 50630812!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self  m1:  cashier  m2: ammount   m3: bookOfSells ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:30:34'!
ERROR!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:47' prior: 50630868!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self  m1:  cashier  m2: bookOfSells   m3: ammount ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:30:48'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:31:33' prior: 50630845!
m1: cashier m2: bookOfSells m3: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:32:08' prior: 50630856!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self m1: instanceFactory cashierWithACartWithABook m2: OrderedCollection  new  m3: 500002 ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:16'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:32:20' prior: 50630934!
test02checkingOutCartWithAnElementShouldDoSomething

	self m1: instanceFactory cashierWithACartWithABook m2: OrderedCollection  new  m3: 500002 ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:21'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:32:52' prior: 50630884!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  m1:  instanceFactory cashierWithACartWithTwoBooks  m2: OrderedCollection  new   m3: 500003 ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:53'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:34:48'!
assertCheckingoutTheCashier: cashier affectsTheSalesBooks: bookOfSells anDebitTheAmmount: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:34:48' prior: 50630974!
test02checkingOutCartWithAnElementShouldDoSomething

	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook affectsTheSalesBooks: OrderedCollection  new  anDebitTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:34:48' prior: 50631009!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  assertCheckingoutTheCashier:  instanceFactory cashierWithACartWithTwoBooks  affectsTheSalesBooks: OrderedCollection  new   anDebitTheAmmount: 500003 ! !

!methodRemoval: CashierForSaleTest #m1:m2:m3: stamp: 'JB 6/10/2023 19:34:48'!
m1: cashier m2: bookOfSells m3: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:35:51' prior: 50630673!
test01checkoutEmptyCartShouldRaiseAnError

	self checkoutForCashier: instanceFactory  cashierWithEmptyCart  
		withCreditCard: instanceFactory  validCreditCard 
		 shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: CashierForSale cannotCheckoutEmptyCart! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:35:52'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:05' prior: 50631057!
test02checkingOutCartWithAnElementShouldDoSomething

	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
		 anDebitTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:06' prior: 50631126!
test02checkingOutCartWithAnElementShouldDoSomething

	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
			 anDebitTheAmmount: 500002 ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:08'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:11' prior: 50631136!
test02checkingOutCartWithAnElementShouldDoSomething
	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
			 anDebitTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:22' prior: 50631067!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  assertCheckingoutTheCashier:  instanceFactory cashierWithACartWithTwoBooks 
		 affectsTheSalesBooks: OrderedCollection  new   
			anDebitTheAmmount: 500003 ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:23'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:41'!
assertCheckingoutTheCashier: cashier affectsTheSalesBooks: bookOfSells anDebitsTheAmmount: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:41' prior: 50631173!
test02checkingOutCartWithAnElementShouldDoSomething
	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
			 anDebitsTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:41' prior: 50631183!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  assertCheckingoutTheCashier:  instanceFactory cashierWithACartWithTwoBooks 
		 affectsTheSalesBooks: OrderedCollection  new   
			anDebitsTheAmmount: 500003 ! !

!methodRemoval: CashierForSaleTest #assertCheckingoutTheCashier:affectsTheSalesBooks:anDebitTheAmmount: stamp: 'JB 6/10/2023 19:36:41'!
assertCheckingoutTheCashier: cashier affectsTheSalesBooks: bookOfSells anDebitTheAmmount: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:39:12'!
crateCorrectlyDatedCashierForTheCart: aShoppingCart

	^ CashierForSale forTheShoppingCart: (aShoppingCart ) withDate: (GregorianMonthOfYear year: 2023   month: June ) debitSaleWithTheDebitator: MerchantProcessorSimulator new.! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:39:12' prior: 50626768!
cashierWithACartWithABook
	^self crateCorrectlyDatedCashierForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:39:12' prior: 50626782!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self crateCorrectlyDatedCashierForTheCart:  cart
 
 ! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:39:12' prior: 50626799!
cashierWithEmptyCart
	^self crateCorrectlyDatedCashierForTheCart:  self createEmptyCart ! !

!methodRemoval: InstanceFactory #createCashierDatadForTheCart: stamp: 'JB 6/10/2023 19:39:12'!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale forTheShoppingCart: (aShoppingCart ) withDate: (GregorianMonthOfYear year: 2023   month: June ) debitSaleWithTheDebitator: MerchantProcessorSimulator new.!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:39:16'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:43:04' prior: 50629824!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].
		
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:05'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:43:43' prior: 50631334!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].		
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:44'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:43:48' prior: 50631371!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].		
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:44:29'!
checkForNoFunds: aCreditCard
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].		
! !
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:44:48'!
checkForCrimes: aCreditCard
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:45:17' prior: 50631408!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	self checkForNoFunds:  aCreditCard .
	self checkForCrimes:  aCreditCard ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:45:18'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:45:55'!
checkForRobbedCreditCard: aCreditCard
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !
!MerchantProcessorSimulator methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:45:55' prior: 50631438!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	self checkForNoFunds:  aCreditCard .
	self checkForRobbedCreditCard:  aCreditCard ! !

!methodRemoval: MerchantProcessorSimulator #checkForCrimes: stamp: 'JB 6/10/2023 19:45:55'!
checkForCrimes: aCreditCard
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!
!CartTest methodsFor: 'support' stamp: 'JB 6/10/2023 19:47:04' prior: 50625749!
createCart
	
	^InstanceFactory  new  createEmptyCart  ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:47:33' prior: 50625674!
test01NewCartsAreCreatedEmpty

	self assert: self instanceFactory createEmptyCart  isEmpty! !

TestCase subclass: #CartTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'JB 6/10/2023 19:47:54'!
TestCase subclass: #CartTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'support' stamp: 'JB 6/10/2023 19:48:14' overrides: 16961394!
setUp
	instanceFactory  := InstanceFactory  new    ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:20'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:20'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:48:38' prior: 50631548!
test01NewCartsAreCreatedEmpty

	self assert: instanceFactory  createEmptyCart  isEmpty! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:40'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:49:20' prior: 50625679!
test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [ cart add: self itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:49:38' prior: 50625692!
test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: self itemSellByTheStore.
	self deny: cart isEmpty ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:49:47'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:49:47'!
PASSED!

!methodRemoval: CartTest #createCart stamp: 'JB 6/10/2023 19:49:51'!
createCart
	
	^InstanceFactory  new  createEmptyCart  !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:49:56'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:49:56'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:49:56'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:50:43' prior: 50625700!
test04CanNotAddNonPositiveNumberOfItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [cart add: 0 of: instanceFactory  itemSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidQuantityErrorMessage.
			self assert: cart isEmpty ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:50:46'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:50:46'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:50:46'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:50:46'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:51:07' prior: 50625713!
test05CanNotAddMoreThanOneItemNotSellByTheStore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [cart add: 2 of: instanceFactory itemNotSellByTheStore  ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:12'!
ERROR!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:51:20'!
itemNotSellByTheStore
	self shouldBeImplemented.! !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:51:45' prior: 50631790!
itemNotSellByTheStore
	^'Harry Potter :(' ! !

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:47'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:51:49'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:51:49'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:51:49'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:52:04' prior: 50625726!
test06CartRemembersAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: instanceFactory  itemSellByTheStore.
	self assert: (cart includes: self itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:05'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:06'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:06'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:52:20' prior: 50625734!
test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self deny: (cart includes: self itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:21'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:21'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:52:35' prior: 50625741!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: 2 of: self itemSellByTheStore.
	self assert: (cart occurrencesOf: self itemSellByTheStore) = 2! !

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:37'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!methodRemoval: CartTest #defaultCatalog stamp: 'JB 6/10/2023 19:52:44'!
defaultCatalog
	|catalog| 
	catalog := Dictionary  new. 
	catalog add:( Association  key:  self itemSellByTheStore  value:  500002). 
	catalog add:( Association  key:  'Full Moon'   value:  1). 

	^ catalog!

!methodRemoval: CartTest #itemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:46'!
itemNotSellByTheStore
	
	^'invalidBook'!

!methodRemoval: CartTest #itemSellByTheStore stamp: 'JB 6/10/2023 19:52:48'!
itemSellByTheStore
	
	^ 'validBook'!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:53'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:53'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:53'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:06'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:06'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:06'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:06'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:09' prior: 50631632!
test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [ cart add: instanceFactory itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:11'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:11'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:11'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:11'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:24' prior: 50631645!
test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: instanceFactory itemSellByTheStore.
	self deny: cart isEmpty ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:25'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:25'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:25'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:34' prior: 50631828!
test06CartRemembersAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: instanceFactory  itemSellByTheStore.
	self assert: (cart includes: instanceFactory itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:35'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:36'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:43' prior: 50631862!
test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self deny: (cart includes: instanceFactory itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:45'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:45'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:45'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:45'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:45'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:57' prior: 50631898!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: 2 of: instanceFactory itemSellByTheStore.
	self assert: (cart occurrencesOf: self itemSellByTheStore) = 2! !

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:54:01'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:54:11' prior: 50632147!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: 2 of: instanceFactory itemSellByTheStore.
	self assert: (cart occurrencesOf: instanceFactory itemSellByTheStore) = 2! !

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:54:13'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

----QUIT----(10 June 2023 20:08:27) CuisUniversity-5832.image priorSource: 9407797!

----STARTUP---- (10 June 2023 20:11:06) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


----QUIT----(10 June 2023 20:11:28) CuisUniversity-5832.image priorSource: 9617528!

----STARTUP---- (23 June 2023 18:11:57) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


!classRemoval: #MerchantProcessorSimulator stamp: 'JB 6/23/2023 18:12:11'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: 'creditCardWithoutFunds stolenCreditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InstanceFactory stamp: 'JB 6/23/2023 18:12:11'!
Object subclass: #InstanceFactory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'JB 6/23/2023 18:12:11'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate creditCardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierForSale stamp: 'JB 6/23/2023 18:12:12'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart date gregorianMonthOfYear creditCardDebitator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'JB 6/23/2023 18:12:12'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierForSaleTest stamp: 'JB 6/23/2023 18:12:12'!
TestCase subclass: #CashierForSaleTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'JB 6/23/2023 18:12:13'!
TestCase subclass: #CartTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\juanb\Desktop\facultad\1C23\IS1\git\2023-1c\10-CustomerImporter\CustomerImporter.st----!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:13:27'!
PASSED!
!Customer methodsFor: 'importing' stamp: 'JB 6/23/2023 18:16:04'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!methodRemoval: Customer class #importCustomers stamp: 'JB 6/23/2023 18:16:05'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:42'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:16:50' prior: 50632272!
test01Import

	Customer new importCustomers ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:55'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:56'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:18:06'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:18:26' prior: 50632627!
test01Import

	self importCustomers ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:18:27'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:18:28'!
PASSED!
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:20:38' prior: 50632636!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:21:20' prior: 50632686!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'JB 6/23/2023 18:21:21'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:30' prior: 50632726!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:39' overrides: 16961394!
setUp

	^ session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:39' prior: 50632773!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:48' prior: 50632819!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:54' prior: 50632813 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:22:22' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:22:23' prior: 50632856!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:22:34' prior: 50632904!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:23:30' prior: 50632894 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:23:33'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:23:33'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:28:56' prior: 50632677!
test01Import

	self importCustomers .
	
	session  selectAllOfType:  Customer. ! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:31:07' prior: 50632988!
test01Import

	self importCustomers .
	
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:31:09'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:31:09'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:31:24' prior: 50632994!
test01Import
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:32:01'!
test01ImportCustomersImportsTwoCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !

!methodRemoval: ImportTest #test01Import stamp: 'JB 6/23/2023 18:32:01'!
test01Import
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:32:27'!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:32:48'!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:32:50'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:32:51'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:32:51'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:32:52'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:33:53' prior: 50633023!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 
		(Set with: '' with: ''  )
	 equals: (session  selectAllOfType:  Customer). ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:33:55'!
FAILURE!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:37:24' prior: 50633051!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 
			 (session  select: [:aCustomer| 
				(aCustomer  firstName = 'Pepe' ) and: (aCustomer  lastName = 'Sanchez' )  
				]  ofType: Customer)   .! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:37:32'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:40:09' prior: 50633062!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)   .! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:40:13'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:40:24'!
identifyAsNumber: aRenameMe1 ofType: aRenameMe2 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:40:44' prior: 50633087!
identifyAsNumber: aNumberOfIdentity ofType: aRenameMe2 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:40:53' prior: 50633092!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:41:49' prior: 50633098!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	(aNumberOfIdentity  = identificationNumber  ) and: (aNumberOfIdentity  =identificationType ).  ! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:41:52' prior: 50633104!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	(aNumberOfIdentity  = identificationNumber  ) and: (aNumberOfIdentity  =identificationType ).  ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:41:54'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:42:32' prior: 50633112!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity  = identificationNumber  ) and: (aNumberOfIdentity  =identificationType ).  ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:42:34'!
ERROR!

identificationNumber!

aNumberOfIdentity!

identificationNumber!

identificationType!

aNumberOfIdentity!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:43:20' prior: 50633123!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity  = identificationNumber  ) and: (tipeOfIdentity  =identificationType ).  ! !

tipeOfIdentity!

identificationNumber!

identificationType!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:44:00' prior: 50633138!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity  =  identificationNumber  ) and: (tipeOfIdentity  = identificationType ).  ! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:45:42' prior: 50632940!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:45:45'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:45:46'!
ERROR!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:45:47'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:45:47'!
ERROR!

aCustomer identifyAsNumber:'22333444' ofType: 'D' !

identificationNumber!

identificationType!

tipeOfIdentity!

identificationType!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:46:56' prior: 50633148!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity asUnicodeString   =  identificationNumber  ) and: (tipeOfIdentity asUnicodeString  = identificationType ).  ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:46:59'!
ERROR!

identificationNumber!

aNumberOfIdentity asUnicodeString!

tipeOfIdentity asUnicodeString  = identificationType!

identificationNumber!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:48:53'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:49:50' prior: 50633075!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  .! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:49:52'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:49:53'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:49:54'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:49:54'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:50:00' prior: 50633229!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  .! !

 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  .!

a Customer!

self at: 1!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:52:10' prior: 50633251!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty  
			.! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:52:11'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:52:12'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:52:12'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:52:13'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:52:45' prior: 50633264!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:53:10' prior: 50633287!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:53:14'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:53:14'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:53:15'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:53:15'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:53:33' prior: 50633030!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:57:33' prior: 50633329!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	self assert: 
		2 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses  size) .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:57:36'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:57:37'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:57:38'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:57:38'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:58:15' prior: 50633334!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	self assert: 
		2 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses  size) .
	self assert: 
		1 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses  size) .
	
! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:58:18'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:58:19'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:58:20'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:58:20'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:04:01' prior: 50633363!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
"
	self assert: 
		2 equals: 
	
			 size) .
	self assert: 
		1 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses  size) .
	
"! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:11:09' prior: 50633393!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		addressOfPepe  select:[:anAddress |
			(anAddress  province = ' ')  and: 
				(anAddress  zipCode  = ''  and: 
					(anAddress  streetName  = ' ' and: 
						(anAddress  streetNumber  = ' ' and:  
							(anAddress  town = ''))))		
		]isEmpty ).! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:11:11'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:11:29' prior: 50633411!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		addressOfPepe  select:[:anAddress |
			(anAddress  province = ' ')  and: 
				(anAddress  zipCode  = ''  and: 
					(anAddress  streetName  = ' ' and: 
						(anAddress  streetNumber  = ' ' and:  
							(anAddress  town = ''))))		
		] isEmpty ).! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:11:45'!
ERROR!

addressOfPepe  select:[:anAddress |
			(anAddress  province = ' ')  and: 
				(anAddress  zipCode  = ''  and: 
					(anAddress  streetName  = ' ' and: 
						(anAddress  streetNumber  = ' ' and:  
							(anAddress  town = ''))))		
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:13:54' prior: 50633433!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = '1636'  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = '3322' and:  
							(anAddress  town = 'Olivos'))))		
		] isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:13:57'!
ERROR!

addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = '1636'  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = '3322' and:  
							(anAddress  town = 'Olivos'))))		
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:14:24' prior: 50633463!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = '1636'  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = '3322' and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:14:27'!
FAILURE!

anAddress!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:15:08' prior: 50633494!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:15:10'!
FAILURE!

anAddress!
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 19:16:03' prior: 50633156!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:16:06'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:16:07'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:16:08'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:17:27' prior: 50633518!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:17:32'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:17:32'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:17:33'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:17:34'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:18:15' prior: 50633588!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:19:14' prior: 50633639!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:19:16'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:19:16'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:19:17'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:19:18'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:29:51' prior: 50633682!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	" 
	
	self assert: addressOfPepe   hasAddress:  
		]
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

	"! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:29:55'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:29:55'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:29:56'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:29:57'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:32:32' prior: 50633739!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).
	" 
	
	self assert: addressOfPepe   hasAddress:  
		]
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

	"! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:32:37'!
ERROR!
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:32:45'!
itsFromProvince: aRenameMe1 streetName: aRenameMe2 streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	self shouldBeImplemented.! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:33:17' prior: 50633842!
itsFromProvince: aRenameMe1 streetName: aRenameMe2 streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:33:19'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:33:19'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:33:20'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:33:21'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:35:37' prior: 50633797!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:35:39'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:35:40'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:35:40'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:35:41'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:36:42' prior: 50633874!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode: 1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:36:43'!
FAILURE!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:36:50'!
FAILURE!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:37:12' prior: 50633925!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1001
			  town:  'CABA'
			  zipCode:  1122
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:37:14'!
FAILURE!

anAddress!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:38:28' prior: 50633968!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:38:32'!
FAILURE!

(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )!

addressOfJuan!

addressOfJuan!

an Address!

anAddress!

anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001!
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:41:33' prior: 50633849!
itsFromProvince: aProvince streetName: aRenameMe2 streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:41:46' prior: 50634059!
itsFromProvince: aProvince streetName: anStreetName streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:41:54' prior: 50634071!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:42:01' prior: 50634083!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:42:17' prior: 50634095!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown zipCode: aZipAddrress 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:43:10' prior: 50634107!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown zipCode: aZipCode 
	^(  province = aProvince )  and: 
				(  zipCode  = aZipCode  and: 
					(  streetName  = anStreetName and: 
						(  streetNumber  = anStreetNumber and:  
							(  town =  aTown ))))		! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:43:12'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:43:14'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:43:15'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:43:15'!
PASSED!

----SNAPSHOT----(23 June 2023 19:49:11) CuisUniversity-5832.image priorSource: 9617744!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:57:40' prior: 50633301!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:57:53'!
sessionHas

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:57:54' prior: 50634148!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
	
			 self sessionHas .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:58:57'!
sessionHas: anIdentityNumber

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 19:58:57' prior: 50634169!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
	
			 self sessionHas: '22333444' .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !

!methodRemoval: ImportTest #sessionHas stamp: 'JB 6/23/2023 19:58:57'!
sessionHas

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 19:58:57' prior: 50634180!
sessionHas: anIdentityNumber

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: 'D' 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:59:40'!
sessionHas: anIdentityNumber identityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: 'D' 
				]  ofType: Customer)  isEmpty! !

!methodRemoval: ImportTest #sessionHas: stamp: 'JB 6/23/2023 19:59:40'!
sessionHas: anIdentityNumber

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: 'D' 
				]  ofType: Customer)  isEmpty!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 19:59:40' prior: 50634215!
sessionHas: anIdentityNumber identityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:00:09'!
sessionHasACustomerWithIdentityNumber: anIdentityNumber andIdentityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty! !

!methodRemoval: ImportTest #sessionHas:identityType: stamp: 'JB 6/23/2023 20:00:09'!
sessionHas: anIdentityNumber identityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:01:29' prior: 50634188!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
			(self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:01:33'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:01:34'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:01:34'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:01:35'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:01:42' prior: 50634260!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self assert: 
			(self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:01:55' prior: 50634241!
sessionHasACustomerWithIdentityNumber: anIdentityNumber andIdentityType: identityType 

	^ ((session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty ) not! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:01:57'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:01:57'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:01:58'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:03:11' prior: 50634287!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self assert: 
			(self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )
			! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:03:13'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:03:14'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:03:14'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:03:15'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:03:23' prior: 50634320!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:03:33' prior: 50634345!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:04:37'!
sessionHasCustomerPepeAndJuan

	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:04:37' prior: 50634357!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	self sessionHasCustomerPepeAndJuan
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:07:31' prior: 50634368!
sessionHasCustomerPepeAndJuan

	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:08:58' prior: 50634378!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:09:03' prior: 50633011!
test01ImportCustomersImportsTwoCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. 
	self sessionHasCustomerPepeAndJuan
			! !

!methodRemoval: ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:09:06'!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:09:09'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:09:13'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:10:52' prior: 50634008!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:11:20' prior: 50634420!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  addresses select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:37' prior: 50634455!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:59'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:59' prior: 50634491!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:37' prior: 50634535!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1: stamp: 'JB 6/23/2023 20:14:24'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:15:41'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:15:41' prior: 50634566!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:16:15'!
m1: addressOfPepe province: aProvince 

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:16:16' prior: 50634618!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1: stamp: 'JB 6/23/2023 20:16:16'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:16:16' prior: 50634649!
m1: addressOfPepe province: aProvince 

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:17:06'!
m1: addressOfPepe province: aProvince streetName: aStreetName  

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:06' prior: 50634659!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province: stamp: 'JB 6/23/2023 20:17:06'!
m1: addressOfPepe province: aProvince 

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:06' prior: 50634708!
m1: addressOfPepe province: aProvince streetName: aStreetName  

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:17:43'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: streetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:43' prior: 50634719!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName: stamp: 'JB 6/23/2023 20:17:43'!
m1: addressOfPepe province: aProvince streetName: aStreetName  

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:44' prior: 50634771!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: streetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  streetNumber  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:18:02' prior: 50634827!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:18:31'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown    

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:18:31' prior: 50634783!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName:streetNumber: stamp: 'JB 6/23/2023 20:18:31'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:18:31' prior: 50634850!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown    

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:19:04'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:19:04' prior: 50634863!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName:streetNumber:aTown: stamp: 'JB 6/23/2023 20:19:04'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown    

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:19:04' prior: 50634921!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:20:06'!
aCustomer: addressOfPepe HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:20:06' prior: 50634934!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName:streetNumber:aTown:andZipCode: stamp: 'JB 6/23/2023 20:20:06'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:19:04' prior: 50635007!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:21:57'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:20:06' prior: 50635056!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:22:19'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:22:43' prior: 50634993!
aCustomer: addressOfPepe HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ (addressOfPepe addresses)  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:22:45'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:22:45'!
ERROR!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:22:46'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:23:02' prior: 50635094!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan addresses   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:23:10' prior: 50635132!
aCustomer: addressOfPepe HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:24:27' prior: 50635191!
aCustomer: aCustomer HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ aCustomer addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:28:38' prior: 50635156!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(self aCustomer:  addressOfPepe
		 HasAnAddressInTheprovince:   'Buenos Aires' 
		withStreetName: 'Maipu' 
		 streetNumber:  888
		aTown:  'Florida'
		andZipCode: 1122  ) isEmpty) .
	

	
	self deny:( 
		(addressOfJuan addresses   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:28:39'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:28:40'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:28:41'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:30:15' prior: 50635219!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(self aCustomer:  addressOfPepe
		 HasAnAddressInTheprovince:   'Buenos Aires' 
		withStreetName: 'Maipu' 
		 streetNumber:  888
		aTown:  'Florida'
		andZipCode: 1122  ) isEmpty) .
	

	
	self deny:( 
		(self aCustomer:addressOfJuan 
		 HasAnAddressInTheprovince:  'CABA'
		withStreetName:'Alem'  
		streetNumber:  1122
		aTown:  'CABA'
		andZipCode: 1001  )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:16'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:30:16'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:17'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:21'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:30:22'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:23'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:30:57' prior: 50635205!
aCustomer: aCustomer HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ aCustomer 
			hasAnAddressThatitsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:31:00'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:31:00'!
ERROR!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:31:01'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 20:31:11'!
hasAnAddressThatitsFromProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 20:32:53' prior: 50635339!
hasAnAddressThatitsFromProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode 
	^(addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode] isEmpty  not)  ! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:32:57'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 20:33:25' prior: 50635347!
hasAnAddressThatitsFromProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode 
	^(addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode] )isEmpty  not ! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:33:28'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:34:21' prior: 50635264!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self assert:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 ) ).

	

	self assert:( 
		(self aCustomer:  addressOfPepe
		 HasAnAddressInTheprovince:   'Buenos Aires' 
		withStreetName: 'Maipu' 
		 streetNumber:  888
		aTown:  'Florida'
		andZipCode: 1122  ) ) .
	

	
	self assert:( 
		(self aCustomer:addressOfJuan 
		 HasAnAddressInTheprovince:  'CABA'
		withStreetName:'Alem'  
		streetNumber:  1122
		aTown:  'CABA'
		andZipCode: 1001  ) ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:34:24'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:34:26'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:34:27'!
PASSED!

----QUIT----(23 June 2023 20:41:46) CuisUniversity-5832.image priorSource: 9679802!