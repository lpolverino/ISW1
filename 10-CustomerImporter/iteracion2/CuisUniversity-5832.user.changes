

----QUIT----(30 May 2023 00:05:32) CuisUniversity-5832.image priorSource: 4928100!

----STARTUP---- (30 May 2023 00:05:33) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5832.image!


----QUIT----(30 May 2023 00:05:33) CuisUniversity-5832.image priorSource: 9366537!

----STARTUP---- (6 June 2023 13:05:16) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


TestCase subclass: #ShoppingCartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

!classDefinition: #ShoppingCartTest category: 'TusLibros01' stamp: 'JB 6/6/2023 13:05:50'!
TestCase subclass: #ShoppingCartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

!classDefinition: #ShoppingCart category: 'TusLibros01' stamp: 'JB 6/6/2023 13:07:14'!
Object subclass: #ShoppingCart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!
!ShoppingCartTest methodsFor: 'nil' stamp: 'JB 6/6/2023 13:07:10'!
test01CreatingAShopingCartShouldBeEmpty
	self  assert:  ShoppingCart new isEmpty! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:07:18'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:07:26'!
isEmpty
	self shouldBeImplemented.! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:07:37' prior: 50624396!
isEmpty
	^true! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:07:39'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:07:39'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:08:54'!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := ShoppingCart new. 
	cart add: #Book. 	
	self  deny:  ShoppingCart new isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:08:55'!
ERROR!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:10:17' prior: 50624410!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := ShoppingCart new. 
	cart add: #Book  quantity: 1. 	
	self  deny:  ShoppingCart new isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:10:20'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:10:25'!
add: aRenameMe1 quantity: aRenameMe2 
	self shouldBeImplemented.! !

!classDefinition: #ShoppingCart category: 'TusLibros01' stamp: 'JB 6/6/2023 13:10:48'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'book'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:10:46' prior: 50624433!
add: aBook quantity: aQuantity 
	book := aBook ! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:10:50'!
FAILURE!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:11:07' prior: 50624422!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := ShoppingCart new. 
	cart add: #Book  quantity: 1. 	
	self  deny:  cart isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:11:08'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:11:54' prior: 50624400!
isEmpty

	book  ifNil:  [
			^true		
		].
	^false
! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:11:55'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:11:55'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:13:31'!
test03anEmptyShoppingCartShouldListAnEmptyList

	self  assert:  OrderedCollection  new equals: ShoppingCart new list! !

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:13:34'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:13:41'!
list
	self shouldBeImplemented.! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:13:52' prior: 50624487!
list
	^OrderedCollection new! !

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:13:54'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:13:54'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:13:54'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:13:54'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:14:56'!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:14:58'!
FAILURE!

!classDefinition: #ShoppingCart category: 'TusLibros01' stamp: 'JB 6/6/2023 13:15:31'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'book books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:15:30' prior: 50624491!
list
	^books! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:15:54' overrides: 16920235!
initialize
	books :=  OrderedCollection new. ! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:16:13' prior: 50624445!
add: aBook quantity: aQuantity 
	books add: aBook ! !
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:16:27' prior: 50624465!
isEmpty

	^books isEmpty ! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:16:40'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:16:41'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:16:41'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:16:41'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:18:27'!
test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:18:28'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:18:28'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:19:04'!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!methodRemoval: ShoppingCartTest #test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:19:04'!
test04AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:23:02'!
test06addingABookOfAnotherEditorialShouldRaiseAnError
|cart|
	cart := ShoppingCart new. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:23:05'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:23:05'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:30:06' prior: 50624622!
test06addingABookOfAnotherEditorialShouldRaiseAnError
|cart|
	cart := ShoppingCart new. 
	self should: [
		cart add: #ElCapital  quantity: 1. 	
		]
	
	 raise: Error
	withExceptionDo: [:anError |
		self assert: anError messageText  equals: ShoppingCart  bookFromAnotherEditorialErrorMessage
		
		]
	
	
		! !

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:30:08'!
FAILURE!
!ShoppingCart class methodsFor: 'no messages' stamp: 'JB 6/6/2023 13:30:44'!
bookFromAnotherEditorialErrorMessage
	^'mmhmh ' ! !

!testRun: #ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:30:58'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:32:48' prior: 50624539!
add: aBook quantity: aQuantity 	 
	books add: aBook ! !

!methodRemoval: ShoppingCartTest #test06addingABookOfAnotherEditorialShouldRaiseAnError stamp: 'JB 6/6/2023 13:32:55'!
test06addingABookOfAnotherEditorialShouldRaiseAnError
|cart|
	cart := ShoppingCart new. 
	self should: [
		cart add: #ElCapital  quantity: 1. 	
		]
	
	 raise: Error
	withExceptionDo: [:anError |
		self assert: anError messageText  equals: ShoppingCart  bookFromAnotherEditorialErrorMessage
		
		]
	
	
		!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:35:17'!
test06addingABookWithAnNegativeQuantityShouldRaisAnError
|cart|
	cart := ShoppingCart new. 
	
	self  should:[
		cart add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !
!ShoppingCart class methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:35:43'!
negativeQuantityErrorMessage
	^'No se puede poner cantidades negativas' ! !

!methodRemoval: ShoppingCart class #bookFromAnotherEditorialErrorMessage stamp: 'JB 6/6/2023 13:35:45'!
bookFromAnotherEditorialErrorMessage
	^'mmhmh ' !

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:35:52'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:38:29' prior: 50624685!
add: aBook quantity: aQuantity 	
	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]. 
 
	books add: aBook ! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:38:32'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:38:35'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:38:35'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:45:03'!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := ShoppingCart new. 
	cart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:45:04'!
FAILURE!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:45:51' prior: 50624730!
add: aBook quantity: aQuantity 	
	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]. 
	1 to: aQuantity do: [
			books add: aBook 		
		]  


! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:45:53'!
ERROR!
!ShoppingCart methodsFor: 'category-name' stamp: 'JB 6/6/2023 13:46:24' prior: 50624806!
add: aBook quantity: aQuantity 	
	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:46:25'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:46:25'!
PASSED!
!ShoppingCart class methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:46:56'!
zeroQuantityErrorMessage
	^'No se puede poner cantidades nulas' ! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00'!
creatEmptyCart

	^ ShoppingCart new! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624477!
test03anEmptyShoppingCartShouldListAnEmptyList

	self  assert:  OrderedCollection  new equals: self creatEmptyCart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624790!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self creatEmptyCart. 
	cart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624387!
test01CreatingAShopingCartShouldBeEmpty
	self  assert:  self creatEmptyCart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624454!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := self creatEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  deny:  cart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624598!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self creatEmptyCart. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624703!
test06addingABookWithAnNegativeQuantityShouldRaisAnError
|cart|
	cart := self creatEmptyCart. 
	
	self  should:[
		cart add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:00' prior: 50624509!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self creatEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25'!
createEmptyCart

	^ ShoppingCart new! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624910!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self createEmptyCart. 
	cart add: #Twilight  quantity: 1. 	
	cart add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624902!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := self createEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  deny:  cart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624922!
test06addingABookWithAnNegativeQuantityShouldRaisAnError
|cart|
	cart := self createEmptyCart. 
	
	self  should:[
		cart add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624935!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self createEmptyCart. 
	cart add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624896!
test01CreatingAShopingCartShouldBeEmpty
	self  assert:  self createEmptyCart isEmpty! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624877!
test03anEmptyShoppingCartShouldListAnEmptyList

	self  assert:  OrderedCollection  new equals: self createEmptyCart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:51:25' prior: 50624884!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self createEmptyCart. 
	cart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !

!methodRemoval: ShoppingCartTest #creatEmptyCart stamp: 'JB 6/6/2023 13:51:25'!
creatEmptyCart

	^ ShoppingCart new!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:52:48' prior: 50624982!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self createEmptyCart  add: #Book  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:52:49'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:52:49'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:13'!
createACartWithASingleBook

	^ self createEmptyCart  add: #Book  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:14' prior: 50625020!
test04AShoppingCartWithABookShouldListACollectionWithABook
|cart|
	cart := self createACartWithASingleBook. 	
	self  assert:   (OrderedCollection with: #Book) equals: cart list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:53:18'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:53:18'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:28' prior: 50624961!
test02AShoppingCartWithABookShouldNotBeEmpty
|cart|
	cart := self createACartWithASingleBook 
	self  deny:  cart isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:34'!
ERROR!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:53:50' prior: 50625108!
test02AShoppingCartWithABookShouldNotBeEmpty

	self  deny:   self createACartWithASingleBook   isEmpty! !

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:53:51'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:53:51'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:54:09' prior: 50625067!
test04AShoppingCartWithABookShouldListACollectionWithABook

	self  assert:   (OrderedCollection with: #Book) equals: self createACartWithASingleBook  list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:54:10'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:54:10'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:54:39' prior: 50624969!
test06addingABookWithAnNegativeQuantityShouldRaisAnError

	self  should:[
		self createEmptyCart  add: #Twilight  quantity: -1.	
		]  raise:  Error
			withExceptionDo: [ :anError|
				self assert:  anError messageText  equals: ShoppingCart negativeQuantityErrorMessage
				
				]
	 	! !

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:54:40'!
PASSED!

	^ self createEmptyCart  add: #Twilight  quantity: 1!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:55:57' prior: 50625061!
createACartWithASingleBook

	^ self createEmptyCart  add: #Twilight  quantity: 1! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:55:59'!
FAILURE!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:55:59'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:55:59'!
FAILURE!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:56:10' prior: 50625157!
test04AShoppingCartWithABookShouldListACollectionWithABook

	self  assert:   (OrderedCollection with: #Twilight) equals: self createACartWithASingleBook  list! !

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:56:11'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:56:43' prior: 50624949!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self createACartWithASingleBook add: #FullMoon  quantity: 1. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:56:44'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:56:44'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:57:00'!
createACartWithTwoBooks

	^ self createACartWithASingleBook add: #FullMoon  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:57:00' prior: 50625294!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook
|cart|
	cart := self createACartWithTwoBooks. 	
	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals: cart list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:57:14' prior: 50625342!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook

	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals:  self createACartWithTwoBooks list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:25'!
createACartWithTwilightAndFullMoon

	^ self createACartWithASingleBook add: #FullMoon  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:25' prior: 50625352!
test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook

	self  assert:   (OrderedCollection with: #Twilight with: #FullMoon  ) equals:  self createACartWithTwilightAndFullMoon list! !

!methodRemoval: ShoppingCartTest #createACartWithTwoBooks stamp: 'JB 6/6/2023 13:58:25'!
createACartWithTwoBooks

	^ self createACartWithASingleBook add: #FullMoon  quantity: 1!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51'!
createACartWithASingleBookNamedTwilight

	^ self createEmptyCart  add: #Twilight  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51' prior: 50625281!
test04AShoppingCartWithABookShouldListACollectionWithABook

	self  assert:   (OrderedCollection with: #Twilight) equals: self createACartWithASingleBookNamedTwilight  list! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51' prior: 50625361!
createACartWithTwilightAndFullMoon

	^ self createACartWithASingleBookNamedTwilight add: #FullMoon  quantity: 1! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:58:51' prior: 50625119!
test02AShoppingCartWithABookShouldNotBeEmpty

	self  deny:   self createACartWithASingleBookNamedTwilight   isEmpty! !

!methodRemoval: ShoppingCartTest #createACartWithASingleBook stamp: 'JB 6/6/2023 13:58:51'!
createACartWithASingleBook

	^ self createEmptyCart  add: #Twilight  quantity: 1!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:59:30' prior: 50625005!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self createEmptyCart add:  #Twilight  quantity: 	 	2. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:59:31'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 13:59:32'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 13:59:32'!
PASSED!
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 13:59:59'!
createACartWithTwilightTwice

	^ self createEmptyCart add:  #Twilight  quantity: 	 	2! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:00:00' prior: 50625419!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList
|cart|
	cart := self createACartWithTwilightTwice. 
	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: cart  list ! !
!ShoppingCartTest methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:00:19' prior: 50625468!
test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList

	self assert:  (OrderedCollection  with: #Twilight with: #Twilight ) equals: self createACartWithTwilightTwice  list ! !

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 14:00:21'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 14:00:21'!
PASSED!
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:03:54'!
checkIfTheQuantittyIsPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]! !
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:03:55' prior: 50624822!
add: aBook quantity: aQuantity 	
	self checkIfTheQuantittyIsPositive: aQuantity. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:04:34'!
raiseAnErrorIfTheQuantityIsNonPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]! !
!ShoppingCart methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:04:34' prior: 50625531!
add: aBook quantity: aQuantity 	
	self raiseAnErrorIfTheQuantityIsNonPositive: aQuantity. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !

!methodRemoval: ShoppingCart #checkIfTheQuantittyIsPositive: stamp: 'JB 6/6/2023 14:04:34'!
checkIfTheQuantittyIsPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]!
!ShoppingCart methodsFor: 'adding private' stamp: 'JB 6/6/2023 14:06:13'!
assertCanAdd: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]! !
!ShoppingCart methodsFor: 'as yet unclassified' stamp: 'JB 6/6/2023 14:06:13' prior: 50625550!
add: aBook quantity: aQuantity 	
	self assertCanAdd: aQuantity. 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !

!methodRemoval: ShoppingCart #raiseAnErrorIfTheQuantityIsNonPositive: stamp: 'JB 6/6/2023 14:06:13'!
raiseAnErrorIfTheQuantityIsNonPositive: aQuantity

	aQuantity  = 0 ifTrue:  [
		self error: self class  zeroQuantityErrorMessage
		]. 
	aQuantity  < 0 ifTrue:  [
		self error: self class  negativeQuantityErrorMessage  
		]!
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:08:45'!
addBookToTheShoppingCart: aBook   thisAmountOfTimes: aQuantity 
	1 to: aQuantity do: [:aNumberOfIteration |
			books add: aBook 		
		]  


! !
!ShoppingCart methodsFor: 'adding' stamp: 'JB 6/6/2023 14:09:07' prior: 50625578!
add: aBook quantity: aQuantity 	
	self assertCanAdd: aQuantity. 
	self addBookToTheShoppingCart:  aBook  thisAmountOfTimes: aQuantity 

! !

!testRun: #ShoppingCartTest #test01CreatingAShopingCartShouldBeEmpty stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test02AShoppingCartWithABookShouldNotBeEmpty stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test03anEmptyShoppingCartShouldListAnEmptyList stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test04AShoppingCartWithABookShouldListACollectionWithABook stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test05AShoppingCartWithManyBooksShouldListACollectionWithManyABook stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test06addingABookWithAnNegativeQuantityShouldRaisAnError stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

!testRun: #ShoppingCartTest #test07addingAQuantityOfABookIntoAShoppingCartShouldAppearThatQuantityOfTimesInTheList stamp: 'JB 6/6/2023 14:09:08'!
PASSED!

----QUIT----(6 June 2023 14:09:25) CuisUniversity-5832.image priorSource: 9366758!

----STARTUP---- (6 June 2023 14:09:36) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


----QUIT----(6 June 2023 14:15:39) CuisUniversity-5832.image priorSource: 9407583!

----STARTUP---- (10 June 2023 15:15:00) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


!classRemoval: #ShoppingCart stamp: 'JB 6/10/2023 15:15:37'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'book books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

!classRemoval: #ShoppingCartTest stamp: 'JB 6/10/2023 15:15:38'!
TestCase subclass: #ShoppingCartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros01'!

----End fileIn of C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\TusLibros.st----!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:16:48'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:16:48'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:16:48'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:16:48'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:18:32' prior: 50625781!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		InstanceFactory  checkoutWitCreditCard:  InstanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:18:33'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:18:58' prior: 50626119!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		InstanceFactory cashierWithEmptyCart   checkoutWitCreditCard:  InstanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:18:58'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:18:58'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:20:30' prior: 50625794!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := InstanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:21:42' prior: 50625804!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := InstanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 500002 with:  1 ) equals:  bookOfSells! !

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:21:47'!
ERROR!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:22:15'!
ERROR!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:22:35'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:22:35'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:22:35'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:22:35'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:22:38'!
ERROR!

aCreditCard!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:23:33' prior: 50626097!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September ). ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:23:51' prior: 50626051!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:24:01' prior: 50626230!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2014 month: September ). ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:24:03'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:24:03'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:24:03'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:24:07'!
ERROR!

aCreditCard!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:24:37' prior: 50626246!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2024 month: September ). ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:24:39'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:24:39'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:24:39'!
ERROR!

todayDate!
!InstanceFactory class methodsFor: 'category-name' stamp: 'lp 6/8/2023 21:41:17' prior: 50626237!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 3000   month: July ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:26:36' prior: 50626067!
cashierWithEmptyCart
	^Cashier for: self  createEmptyCart ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:26:44' prior: 50626346!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:26:48' prior: 50626355!
cashierWithEmptyCart
	^Cashier for: self  createEmptyCart dated: (GregorianMonthOfYear year: 3000   month: July ). 
 ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:26:50'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:26:50'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:26:50'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:26:50'!
ERROR!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:27:32' prior: 50626361!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 3000   month: July ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:27:48' prior: 50626059!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^Cashier for: cart dated: (GregorianMonthOfYear year: 3000   month: July ). 
 
 ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:27:49'!
ERROR!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:27:49'!
ERROR!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:27:49'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:27:52'!
ERROR!

todayDate!

aCreditCard!

aCreditCard date!

todayDate!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:26' prior: 50626424!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^Cashier for: cart dated: (GregorianMonthOfYear year: 2023   month: July ). 
 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:29' prior: 50626479!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^Cashier for: cart dated: (GregorianMonthOfYear year: 2023   month: June ). 
 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:35' prior: 50626415!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: July ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:43' prior: 50626499!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:52' prior: 50626368!
cashierWithEmptyCart
	^Cashier for: self  createEmptyCart dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:29:31'!
createCashierDatadForTheCart

	^ Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June )! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:29:31' prior: 50626508!
cashierWithACartWithABook
		^self createCashierDatadForTheCart. 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:28:43' prior: 50626533!
cashierWithACartWithABook
		^Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June ). 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:30:21'!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!methodRemoval: InstanceFactory class #createCashierDatadForTheCart stamp: 'JB 6/10/2023 15:30:22'!
createCashierDatadForTheCart

	^ Cashier for: (self createEmptyCart  add: self itemSellByTheStore ) dated: (GregorianMonthOfYear year: 2023   month: June )!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:30:37' prior: 50626547!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:31:02' prior: 50626539!
cashierWithACartWithABook
		
 ^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:31:03'!
FAILURE!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:31:03'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:31:03'!
FAILURE!

bookOfSells!
!Cashier methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:33:05' prior: 50625940!
checkoutWitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		bookOfSells  add: ammount .
		].
	
	
	^ammount 
	
	! !

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:33:08'!
FAILURE!

bookOfSells!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:33:38' prior: 50626189!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := InstanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:33:40'!
PASSED!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:33:59' prior: 50626489!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self createCashierDatadForTheCart:  cart
 
 ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:34:21' prior: 50626517!
cashierWithEmptyCart
	^self createCashierDatadForTheCart:  self createEmptyCart ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:34:23'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:34:23'!
PASSED!
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:34:31' prior: 50626572!
cashierWithACartWithABook
		^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !
!InstanceFactory class methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:34:33' prior: 50626715!
cashierWithACartWithABook
	^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:34:34'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:34:34'!
PASSED!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:35:44'!
cashierWithACartWithABook
	^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !

!methodRemoval: InstanceFactory class #cashierWithACartWithABook stamp: 'JB 6/10/2023 15:35:45'!
cashierWithACartWithABook
	^self createCashierDatadForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:35:53'!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self createCashierDatadForTheCart:  cart
 
 ! !

!methodRemoval: InstanceFactory class #cashierWithACartWithTwoBooks stamp: 'JB 6/10/2023 15:35:53'!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self createCashierDatadForTheCart:  cart
 
 !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:35:58'!
cashierWithEmptyCart
	^self createCashierDatadForTheCart:  self createEmptyCart ! !

!methodRemoval: InstanceFactory class #cashierWithEmptyCart stamp: 'JB 6/10/2023 15:35:58'!
cashierWithEmptyCart
	^self createCashierDatadForTheCart:  self createEmptyCart !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:03'!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!methodRemoval: InstanceFactory class #createCashierDatadForTheCart: stamp: 'JB 6/10/2023 15:36:03'!
createCashierDatadForTheCart: aShoppingCart

	^ Cashier for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:07'!
createEmptyCart
	^Cart acceptingItemsOf: self defaultCatalog! !

!methodRemoval: InstanceFactory class #createEmptyCart stamp: 'JB 6/10/2023 15:36:07'!
createEmptyCart
	^Cart acceptingItemsOf: self defaultCatalog!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:10'!
defaultCatalog
	|catalog| 
	catalog := Dictionary  new. 
	catalog add:( Association  key:  self itemSellByTheStore  value:  500002). 
	catalog add:( Association  key:  'Full Moon'   value:  1). 

	^ catalog! !

!methodRemoval: InstanceFactory class #defaultCatalog stamp: 'JB 6/10/2023 15:36:10'!
defaultCatalog
	|catalog| 
	catalog := Dictionary  new. 
	catalog add:( Association  key:  self itemSellByTheStore  value:  500002). 
	catalog add:( Association  key:  'Full Moon'   value:  1). 

	^ catalog!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:15'!
expiredCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September ). ! !

!methodRemoval: InstanceFactory class #expiredCreditCard stamp: 'JB 6/10/2023 15:36:15'!
expiredCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September ). !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:18'!
itemSellByTheStore
	^ 'validBook'! !

!methodRemoval: InstanceFactory class #itemSellByTheStore stamp: 'JB 6/10/2023 15:36:18'!
itemSellByTheStore
	^ 'validBook'!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:36:22'!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2024 month: September ). ! !

!methodRemoval: InstanceFactory class #validCreditCard stamp: 'JB 6/10/2023 15:36:23'!
validCreditCard
	^CreditCard   date:   ( GregorianMonthOfYear year:  2024 month: September ). !

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'JB 6/10/2023 15:36:43'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:42' prior: 50626139!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWitCreditCard:  InstanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:51' prior: 50626174!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWitCreditCard:  InstanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:54' prior: 50626910!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:36:59' prior: 50626893!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:02' prior: 50626640!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := InstanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:04' prior: 50626957!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:09' prior: 50625814!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := InstanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:11' prior: 50626989!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:32' prior: 50627008!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:37:51' overrides: 16961394!
setUp
	instanceFactory := InstanceFactory  new.
	! !

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:37:52'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:37:52'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:37:52'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:37:52'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:40:34'!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!Cashier methodsFor: 'category-name' stamp: 'JB 6/10/2023 15:41:34'!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		bookOfSells  add: ammount .
		].
	
	
	^ammount 
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50626940!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   Cashier cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50627065!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50626973!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection with: 1 with:  500003 ) equals:  bookOfSells! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50627027!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:41:34' prior: 50626925!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  500002  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !

!methodRemoval: Cashier #checkoutWitCreditCard:registerOn: stamp: 'JB 6/10/2023 15:41:34'!
checkoutWitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		bookOfSells  add: ammount .
		].
	
	
	^ammount 
	
	!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:41:36'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:41:36'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:43:44'!
test07robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierTest #test07robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!

!testRun: #CashierTest #test07robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:43:45'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 15:44:00'!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!methodRemoval: CashierTest #test07robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 15:44:00'!
test07robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: Cashier cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	!

!methodRemoval: Cashier #checkoutWitCreditCard: stamp: 'JB 6/10/2023 17:12:49'!
checkoutWitCreditCard: aCreditCard
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
		].
	^ammount 
	
	
	!

!classRenamed: #Cashier as: #CashierForSell stamp: 'JB 6/10/2023 17:15:10'!
Smalltalk renameClassNamed: #Cashier as: #CashierForSell!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627114!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSell cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627257!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSell cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627149!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSell cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50627097!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSell cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:11' prior: 50626810!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSell for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!classRenamed: #CashierForSell as: #CashierForSale stamp: 'JB 6/10/2023 17:15:34'!
Smalltalk renameClassNamed: #CashierForSell as: #CashierForSale!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:34' prior: 50627309!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:34' prior: 50627329!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:35' prior: 50627348!
test04expiredCreditcardShouldNotProceedWithTheSell
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:35' prior: 50627367!
test01checkoutEmptyCartShouldRaiseAnError
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:15:35' prior: 50627385!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June )! !

!classRenamed: #CashierTest as: #CashierForSaleTest stamp: 'JB 6/10/2023 17:15:46'!
Smalltalk renameClassNamed: #CashierTest as: #CashierForSaleTest!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:15:47'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:15:48'!
PASSED!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 17:16:21'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:16:36' prior: 50627133!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells|
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  500003  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection  with:  500003 ) equals:  bookOfSells! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:16:57' prior: 50627084!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.
	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
	
		].
	
		bookOfSells  add: ammount .
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:17:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:17:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:17:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:17:03'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:17:03'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:17:03'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:18:00'!
test05creditCardWithoutFundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!methodRemoval: CashierForSaleTest #test05creditCardWithoutFoundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:00'!
test05creditCardWithoutFoundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:02'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:18:15'!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!methodRemoval: CashierForSaleTest #test05creditCardWithoutFundShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:15'!
test05creditCardWithoutFundShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProccesSellForExpiredCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:17'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:18:18'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:19:02' prior: 50627634!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:23:06' prior: 50627701!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 	
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!classDefinition: #MerchantProcessorSimulator category: 'TusLibros' stamp: 'JB 6/10/2023 17:30:11'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:30:05' prior: 50627474!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale for: (aShoppingCart ) dated: (GregorianMonthOfYear year: 2023   month: June ) merchantProcessor: MerchantProcessorSimulator new.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 17:30:14'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:30:15'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 17:30:17'!
ERROR!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:31:10'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:31:13'!
ERROR!
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:31:25'!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator ! !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:31:44' prior: 50627835!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:31:46'!
ERROR!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 17:32:03'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 17:32:03'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear merchantProcessorSimulator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:32:03'!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	self shouldBeImplemented.
	cart := aCart.
	gregorianMonthOfYear := aGregorianMonthOfYear.
	merchantProcessorSimulator := aMerchantProcessorSimulator.! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:32:17' prior: 50627878!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	gregorianMonthOfYear := aGregorianMonthOfYear.
	merchantProcessorSimulator := aMerchantProcessorSimulator.! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:32:19'!
ERROR!

todayDate!

!methodRemoval: CashierForSale #initializeFor: stamp: 'JB 6/10/2023 17:32:58'!
initializeFor: aCart 

	cart := aCart.!

!methodRemoval: CashierForSale #initializeFor:dated: stamp: 'JB 6/10/2023 17:33:01'!
initializeFor: aCart dated: aDate 
	
	cart := aCart.
	 todayDate  := aDate.!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:33:13' prior: 50627889!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aGregorianMonthOfYear.
	merchantProcessorSimulator := aMerchantProcessorSimulator.! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:15'!
PASSED!

!methodRemoval: CashierForSale class #for: stamp: 'JB 6/10/2023 17:33:21'!
for: aCart 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"

	^self new initializeFor: aCart !

!methodRemoval: CashierForSale class #for:dated: stamp: 'JB 6/10/2023 17:33:23'!
for: aCart dated: adate 

	^self new initializeFor: aCart dated: adate !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:39'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:33:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:34:05'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:34:11'!
PASSED!

cashier!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:35:38' prior: 50627721!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		self fail.
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:53'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:35:57' prior: 50627995!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		self error.
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:35:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:01'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:36:05' prior: 50628069!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:36:05'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:06'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:06'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:06'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:36:17' prior: 50628143!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells . 
		] raise: Error
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:36:18'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:40:11' prior: 50627532!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
			
		].
	bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		]
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:14'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:20'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:40:25'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:40:25'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:40:28'!
ERROR!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:40:38' prior: 50628236!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
			
		].
	bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:40:40'!
ERROR!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:40:51'!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	self shouldBeImplemented.! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:41:06' prior: 50628309!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	^true! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:41:08'!
FAILURE!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:41:17'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:41:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:42:06'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:43:36' prior: 50628190!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard   registerOn: bookOfSells . 
		] raise: Error
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:38'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:38'!
ERROR!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:43:56' prior: 50628353!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardWithoutFunds   registerOn: bookOfSells . 
		] raise: Error
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:43:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:00'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:03'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:03'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:44:47' prior: 50628380!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardWithoutFunds   registerOn: bookOfSells . 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSellWithNofundsCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:44:48'!
ERROR!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:45:04'!
creditCardWithoutFunds
	self shouldBeImplemented.! !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:48:24' prior: 50628504!
creditCardWithoutFunds
	^CreditCard  number: 1   date:  (GregorianMonthOfYear  month:  September  year: 2024) name: 'Lionel Messi' ! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:48:31'!
ERROR!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:49:38' prior: 50628509!
creditCardWithoutFunds
	^CreditCard  number: 1   date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Lionel Messi' ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:49:57'!
ERROR!
!CreditCard class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:50:05'!
number: aSmallInteger date: aGregorianMonthOfYear name: aString 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeNumber: aSmallInteger date: aGregorianMonthOfYear name: aString ! !
!CreditCard class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 17:51:00' prior: 50628555!
number: creditCardNumber date: expirationDate name: creditCardOwner 
	
	^self new initializeNumber: creditCardNumber date: expirationDate name: creditCardOwner ! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:51:01'!
ERROR!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:09'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:09'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber_CHANGE_ME expirationDate_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:09'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber_CHANGE_ME expirationDate_CHANGE_ME creditCardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:09'!
initializeNumber: creditCardNumber date: expirationDate name: creditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := creditCardNumber.
	expirationDate_CHANGE_ME := expirationDate.
	creditCardOwner_CHANGE_ME := creditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:22' prior: 50628605!
initializeNumber: aCreditCardNumber date: expirationDate name: creditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := aCreditCardNumber.
	expirationDate_CHANGE_ME := expirationDate.
	creditCardOwner_CHANGE_ME := creditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:29' prior: 50628616!
initializeNumber: aCreditCardNumber date: anExpirationDate name: creditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := aCreditCardNumber.
	expirationDate_CHANGE_ME := anExpirationDate.
	creditCardOwner_CHANGE_ME := creditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:51:35' prior: 50628627!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber_CHANGE_ME := aCreditCardNumber.
	expirationDate_CHANGE_ME := anExpirationDate.
	creditCardOwner_CHANGE_ME := aCreditCardOwner.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:43'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate_CHANGE_ME creditCardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:51:43' prior: 50628638!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber := aCreditCardNumber.
	expirationDate_CHANGE_ME := anExpirationDate.
	creditCardOwner_CHANGE_ME := aCreditCardOwner.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:49'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate creditCardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:51:49' prior: 50628659!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber := aCreditCardNumber.
	expirationDate := anExpirationDate.
	creditCardOwner_CHANGE_ME := aCreditCardOwner.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'JB 6/10/2023 17:51:55'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate creditCardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:51:55' prior: 50628679!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	self shouldBeImplemented.
	creditCardNumber := aCreditCardNumber.
	expirationDate := anExpirationDate.
	creditCardOwner := aCreditCardOwner.! !
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:52:00' prior: 50628699!
initializeNumber: aCreditCardNumber date: anExpirationDate name: aCreditCardOwner 
	creditCardNumber := aCreditCardNumber.
	expirationDate := anExpirationDate.
	creditCardOwner := aCreditCardOwner.! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:52:03'!
ERROR!

aCreditCard!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:53:38'!
createLionelMessiCreditCardDated

	^ CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September )! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:53:39' prior: 50626854!
expiredCreditCard
	^self createLionelMessiCreditCardDated. ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:54:15'!
createLionelMessiCreditCardDated: aDate

	^ CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September )! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 17:54:16' prior: 50628730!
expiredCreditCard
	^self createLionelMessiCreditCardDated: dated. ! !

!methodRemoval: InstanceFactory #createLionelMessiCreditCardDated stamp: 'JB 6/10/2023 17:54:16'!
createLionelMessiCreditCardDated

	^ CreditCard   date:   ( GregorianMonthOfYear year:  2010 month: September )!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:54:52' prior: 50628742!
expiredCreditCard
	^self createLionelMessiCreditCardDated: ( GregorianMonthOfYear year:  2010 month: September ). ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:55:15' prior: 50626874!
validCreditCard
	^self createLionelMessiCreditCardDated:   ( GregorianMonthOfYear year:  2024 month: September ). ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:55:44' prior: 50628735!
createLionelMessiCreditCardDated: aDate

	^ CreditCard  number: 1   date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Lionel Messi' ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 17:55:55' prior: 50628768!
createLionelMessiCreditCardDated: aDate

	^ CreditCard  number: 1   date:  aDate name: 'Lionel Messi' ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:57:44'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:57:44'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:57:47'!
ERROR!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:58:10'!
ERROR!
!CreditCard methodsFor: 'category-name' stamp: 'JB 6/10/2023 17:58:35' prior: 50626010!
date
	
	^expirationDate ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:58:40'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:58:41'!
ERROR!

!methodRemoval: CreditCard #initializeDate: stamp: 'JB 6/10/2023 17:59:22'!
initializeDate: aGregorianMonthOfYear 

date := aGregorianMonthOfYear.!

!methodRemoval: CreditCard class #date: stamp: 'JB 6/10/2023 17:59:41'!
date: aGregorianMonthOfYear 

	^self new initializeDate: aGregorianMonthOfYear !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 17:59:50'!
ERROR!

!classDefinition: #MerchantProcessorSimulator category: 'TusLibros' stamp: 'JB 6/10/2023 18:09:02'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: 'creditCardWithoutFunds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #MerchantProcessorSimulator category: 'TusLibros' stamp: 'JB 6/10/2023 18:09:08'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: 'creditCardWithoutFunds stolenCreditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:08:58' prior: 50628316!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard = creditCardWithoutFunds )ifTrue:[
				self error: self class creditCardWithoutFunds 
			] ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCard 
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:09:33' prior: 50628906!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard = creditCardWithoutFunds )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			] ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCardErrorMessage 
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:10:04' prior: 50628919!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard = creditCardWithoutFunds )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			] "ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCardErrorMessage 
				] 
			]"
		! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:10:32'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:10:32'!
ERROR!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:15:32' prior: 50628288!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list do:[:aBook |
		ammount := ammount +  (cart priceFor: aBook). 
			
		].
	bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:19:20' prior: 50628481!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardWithoutFunds   registerOn: bookOfSells . 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: MerchantProcessorSimulator creditCardWithoutFundsErrorMessage.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:19:24'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:19:24'!
ERROR!

aCreditCard!

creditCardWithoutFunds!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:21:00' overrides: 16920235!
initialize
	creditCardWithoutFunds  := InstanceFactory  new creditCardWithoutFunds ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:02'!
FAILURE!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:21:03'!
ERROR!

creditCardWithoutFunds!

creditCardWithoutFunds!

aCreditCard = creditCardWithoutFunds !

aCreditCard!

creditCardWithoutFunds!

creditCardWithoutFunds!

aCreditCard!

self!

anObject!

self == anObject!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:24:37' prior: 50628933!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			] "ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class stollenCreditCardErrorMessage 
				] 
			]"
		! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:24:39'!
ERROR!
!CreditCard methodsFor: 'number' stamp: 'JB 6/10/2023 18:24:52'!
number
	self shouldBeImplemented.! !
!CreditCard methodsFor: 'number' stamp: 'JB 6/10/2023 18:25:05' prior: 50629062!
number
	^creditCardNumber ! !

aCreditCard  number = creditCardWithoutFunds number!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:25:23'!
ERROR!
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:25:30'!
creditCardWithoutFundsErrorMessage
	self shouldBeImplemented.! !
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:26:31' prior: 50629076!
creditCardWithoutFundsErrorMessage
	^'no tiene fondos la tarjeta :)' ! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:35'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:26:40'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:26:40'!
ERROR!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:26:40'!
ERROR!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:40'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:40'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:26:40'!
PASSED!
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 18:27:42' prior: 50628521!
creditCardWithoutFunds
	^CreditCard  number:    2 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Cristiano Ronaldo' ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 18:27:47'!
ERROR!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:27:47'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:26'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:28'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:28:28'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:29:46' prior: 50627418!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale canNotRefactorWithIncompleteTypeInfo.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:30:12' prior: 50629217!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSaleForRobedCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 18:31:56'!
createRobbedCard
	^CreditCard  number:    3 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Robben Van Persy' ! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:33:52' prior: 50629045!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard = stolenCreditCard )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:34:59' prior: 50629001 overrides: 16920235!
initialize
	|instanceFactory |
	instanceFactory := 	InstanceFactory  new. 
	creditCardWithoutFunds  :=  instanceFactory  creditCardWithoutFunds.
	stolenCreditCard := instanceFactory  createRobbedCard. ! !
!InstanceFactory methodsFor: 'credit card' stamp: 'JB 6/10/2023 18:35:17'!
creditCardRobbed
	^CreditCard  number:    3 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Robben Van Persy' ! !
!MerchantProcessorSimulator methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:35:18' prior: 50629279 overrides: 16920235!
initialize
	|instanceFactory |
	instanceFactory := 	InstanceFactory  new. 
	creditCardWithoutFunds  :=  instanceFactory  creditCardWithoutFunds.
	stolenCreditCard := instanceFactory  creditCardRobbed. ! !

!methodRemoval: InstanceFactory #createRobbedCard stamp: 'JB 6/10/2023 18:35:18'!
createRobbedCard
	^CreditCard  number:    3 date:  ( GregorianMonthOfYear year:  2024 month: September) name: 'Robben Van Persy' !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:29'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:36:43'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:37:41' prior: 50629237!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardRobbed   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: CashierForSale cannotProcessSaleForRobedCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:37:44'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:37:44'!
ERROR!
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:38:27' prior: 50629264!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:38:32'!
ERROR!
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:38:38'!
cannotProcessSaleForRobedCreditCard
	self shouldBeImplemented.! !
!MerchantProcessorSimulator class methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:40:24' prior: 50629386!
cannotProcessSaleForRobedCreditCard
	^'tarjeta robada error message' ! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:40:25'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:40:30'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:43:43' prior: 50629341!
test06robedCreditCardShouldNotProceedWithTheSell 
	|cashier  bookOfSells|
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection new. 
	
	self should: [
		cashier  checkoutWhitCreditCard:  instanceFactory  creditCardRobbed   registerOn: bookOfSells 
		] raise: Error-MessageNotUnderstood 
		  description: [:anError |
				self assert:  anError  messageText   equals: MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard.
				self assert: bookOfSells isEmpty 		
			]
	
	! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:43:44'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:54:15' prior: 50628954!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	cart list inject:  ammount  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	
		bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:54:17'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:17'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:17'!
FAILURE!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:54:40' prior: 50629452!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	ammount := 0. 
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	
		bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:42'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:42'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:54:48' prior: 50629493!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	
		bookOfSells  add: ammount .
	(ammount = 0 ) ifFalse:[
		merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount 
		].
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:49'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:54:49'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:55:31' prior: 50629534!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:55:32'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:55:32'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:02'!
checkForEmptyCart

	^ cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:02' prior: 50629575!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	self checkForEmptyCart. 

	self checkForDate: aCreditCard.

	
	ammount := cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		].
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:26'!
calculateTotalAmmount

	^ cart list inject:  0  into: [:anAmmount :aBook|
			anAmmount +  (cart priceFor: aBook). 			
		]! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:26' prior: 50629620!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	
	self checkForEmptyCart. 

	self checkForDate: aCreditCard.

	
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 18:56:45' prior: 50629642!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	merchantProcessorSimulator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 18:56:46'!
PASSED!

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 18:57:11'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear merchantProcessorInteface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:57:11' prior: 50629655!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	merchantProcessorInteface  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:57:11' prior: 50627912!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aGregorianMonthOfYear.
	merchantProcessorInteface := aMerchantProcessorSimulator.! !

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 18:58:34'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart todayDate gregorianMonthOfYear creditCardDebitator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:58:34' prior: 50629700!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	creditCardDebitator  processPurchaseWithCreditCard: aCreditCard  ofTheAmmount: ammount. 
	^ammount 
	
	! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 18:58:34' prior: 50629713!
initializeFor: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aGregorianMonthOfYear.
	creditCardDebitator := aMerchantProcessorSimulator.! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:00:07'!
debitTheAmmount: aCreditCard toTheCreditCard: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:00:07' prior: 50629732!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	creditCardDebitator  debitTheAmmount: aCreditCard  toTheCreditCard: ammount. 
	^ammount 
	
	! !

!methodRemoval: MerchantProcessorSimulator #processPurchaseWithCreditCard:ofTheAmmount: stamp: 'JB 6/10/2023 19:00:07'!
processPurchaseWithCreditCard: aCreditCard ofTheAmmount: ammount 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:00:21' prior: 50629769!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	bookOfSells  add: ammount .
	creditCardDebitator  debitTheAmmount:    ammount  toTheCreditCard: aCreditCard . 
	^ammount 
	
	! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:01:04' prior: 50629755!
debitTheAmmount: anAmmount2debit toTheCreditCard: ammount 
	(anAmmount2debit  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(anAmmount2debit  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !
!MerchantProcessorSimulator methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:01:39' prior: 50629809!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			]ifFalse:[
				(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 
			]
		! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:01:53'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:01:54'!
PASSED!
!CashierForSale methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:02:36' prior: 50629796!
checkoutWhitCreditCard: aCreditCard registerOn: bookOfSells 
	|ammount|
	self checkForEmptyCart. 
	self checkForDate: aCreditCard.
	ammount := self calculateTotalAmmount.
	creditCardDebitator  debitTheAmmount:    ammount  toTheCreditCard: aCreditCard . 
	bookOfSells  add: ammount .
	^ammount 
	
	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:37'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:41'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:02:41'!
PASSED!
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:05:31' prior: 50625924!
checkForDate: aCreditCard 
	( todayDate >  aCreditCard date ) ifTrue:[
			self error: self class cannotProccesSellForExpiredCreditCard 
			]! !
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:06:00' prior: 50629614!
checkForEmptyCart
 cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:06:01'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:06:01'!
PASSED!
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:06:03' prior: 50629928!
checkForEmptyCart
	 cart isEmpty ifTrue:[
			self emptycarterrorMessage	
		]! !
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:07:25' prior: 50625952!
emptycarterrorMessage

! !
!CashierForSale methodsFor: 'checkout private' stamp: 'JB 6/10/2023 19:07:30' prior: 50629957!
checkForEmptyCart
	 cart isEmpty ifTrue:[
			 self error: self class cannotCheckoutEmptyCart	
		]! !

!methodRemoval: CashierForSale #emptycarterrorMessage stamp: 'JB 6/10/2023 19:07:32'!
emptycarterrorMessage

!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:07:43'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:07:43'!
PASSED!
!CashierForSale methodsFor: 'initializing' stamp: 'JB 6/10/2023 19:07:57' prior: 50629745!
initializeFor: aCart dated: aDate merchantProcessor: aMerchantProcessorSimulator 
	cart := aCart.
	todayDate := aDate.
	creditCardDebitator := aMerchantProcessorSimulator.! !
!CashierForSale methodsFor: 'initializing' stamp: 'JB 6/10/2023 19:08:13' prior: 50630000!
initializeFor: aCart dated: aDate merchantProcessor: aCreditCardDebitator 
	cart := aCart.
	todayDate := aDate.
	creditCardDebitator := aCreditCardDebitator.! !

!classDefinition: #CashierForSale category: 'TusLibros' stamp: 'JB 6/10/2023 19:08:25'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart date gregorianMonthOfYear creditCardDebitator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:08:25' prior: 50629920!
checkForDate: aCreditCard 
	( date >  aCreditCard date ) ifTrue:[
			self error: self class cannotProccesSellForExpiredCreditCard 
			]! !
!CashierForSale methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:08:25' prior: 50630009!
initializeFor: aCart dated: aDate merchantProcessor: aCreditCardDebitator 
	cart := aCart.
	date := aDate.
	creditCardDebitator := aCreditCardDebitator.! !
!CashierForSale methodsFor: 'initializing' stamp: 'JB 6/10/2023 19:08:48'!
initializeFor: aCart dated: aDate debitCreditCardWith: aCreditCardDebitator 
	cart := aCart.
	date := aDate.
	creditCardDebitator := aCreditCardDebitator.! !
!CashierForSale class methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:08:48' prior: 50627848!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear debitCreditCardWith: aMerchantProcessorSimulator ! !

!methodRemoval: CashierForSale #initializeFor:dated:merchantProcessor: stamp: 'JB 6/10/2023 19:08:48'!
initializeFor: aCart dated: aDate merchantProcessor: aCreditCardDebitator 
	cart := aCart.
	date := aDate.
	creditCardDebitator := aCreditCardDebitator.!
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:15'!
forTheShoppingCart: aCart withDate: aGregorianMonthOfYear debitSaleWithTheDebitator: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear debitCreditCardWith: aMerchantProcessorSimulator ! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:10:15' prior: 50627748!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale forTheShoppingCart: (aShoppingCart ) withDate: (GregorianMonthOfYear year: 2023   month: June ) debitSaleWithTheDebitator: MerchantProcessorSimulator new.! !

!methodRemoval: CashierForSale class #for:dated:merchantProcessor: stamp: 'JB 6/10/2023 19:10:15'!
for: aCart dated: aGregorianMonthOfYear merchantProcessor: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aGregorianMonthOfYear debitCreditCardWith: aMerchantProcessorSimulator !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:25' prior: 50630069!
forTheShoppingCart: aCart withDate: aDate debitSaleWithTheDebitator: aMerchantProcessorSimulator 
	^self new initializeFor: aCart dated: aDate debitCreditCardWith: aMerchantProcessorSimulator ! !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:36' prior: 50630100!
forTheShoppingCart: aCart withDate: aDate debitSaleWithTheDebitator: aCreditCardDebitator 
	^self new initializeFor: aCart dated: aDate debitCreditCardWith: aCreditCardDebitator ! !
!CashierForSale class methodsFor: 'instance creation' stamp: 'JB 6/10/2023 19:10:45' prior: 50630110!
forTheShoppingCart: aCartToCheckOut withDate: aDate debitSaleWithTheDebitator: aCreditCardDebitator 
	^self new initializeFor: aCartToCheckOut dated: aDate debitCreditCardWith: aCreditCardDebitator ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:11:25'!
xxx
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:12:23'!
xxx: aCashier
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxx stamp: 'JB 6/10/2023 19:12:23'!
xxx
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:13:00'!
xxx: aCashier creditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxx: stamp: 'JB 6/10/2023 19:13:00'!
xxx: aCashier
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:13:21'!
xxxForCashier: aCashier withCreditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxx:creditCard: stamp: 'JB 6/10/2023 19:13:22'!
xxx: aCashier creditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		instanceFactory cashierWithEmptyCart   checkoutWhitCreditCard:  instanceFactory  expiredCreditCard   registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError|
		self assert:  anError messageText   equals:   CashierForSale cannotCheckoutEmptyCart.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:13:57' prior: 50630209!
xxxForCashier: aCashier withCreditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| | aBlock_ |
		self assert:  anError messageText   equals:   aBlock_ value.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:14:52'!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| | aBlock_ |
		self assert:  anError messageText   equals:   aBlock_ value.
		self assert:  		bookOfSells isEmpty 
		]! !

!methodRemoval: CashierForSaleTest #xxxForCashier:withCreditCard: stamp: 'JB 6/10/2023 19:14:52'!
xxxForCashier: aCashier withCreditCard: aCreditCard 
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| | aBlock_ |
		self assert:  anError messageText   equals:   aBlock_ value.
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:14:57' prior: 50630260!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	
	
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock value.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:15:05' prior: 50630292!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock value.
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:16:24' prior: 50627456!
test01checkoutEmptyCartShouldRaiseAnError

	self xxxForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  messageError: [CashierForSale cannotCheckoutEmptyCart]! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:26'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:26'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:16:34' prior: 50630309!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:16:39' prior: 50630325!
test01checkoutEmptyCartShouldRaiseAnError

	self xxxForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  messageError: CashierForSale cannotCheckoutEmptyCart! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:40'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:16:40'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:17:55' prior: 50627437!
test04expiredCreditcardShouldNotProceedWithTheSell
		self xxxForCashier:  
			instanceFactory cashierWithACartWithABook
		 withCreditCard:  
			instanceFactory  expiredCreditCard
		messageError: 
			CashierForSale cannotProccesSellForExpiredCreditCard! !

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:17:57'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:19:09' prior: 50628971!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
		self xxxForCashier:  
			instanceFactory cashierWithACartWithABook	
		 withCreditCard:  
			instanceFactory  creditCardWithoutFunds	
		messageError: 
			MerchantProcessorSimulator creditCardWithoutFundsErrorMessage
	! !

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:19:10'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:11'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:11'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:19:11'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:20:41' prior: 50629406!
test06robedCreditCardShouldNotProceedWithTheSell 
		self xxxForCashier:  
				instanceFactory cashierWithACartWithABook		 
			withCreditCard:  
				instanceFactory  creditCardRobbed
				messageError: 
					MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard
	! !

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:20:42'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53'!
checkoutForCashier: aCashier withCreditCard: aCreditCard shouldRaiseAnErrorWithDescription: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630378!
test01checkoutEmptyCartShouldRaiseAnError

	self checkoutForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  shouldRaiseAnErrorWithDescription: CashierForSale cannotCheckoutEmptyCart! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630415!
test04expiredCreditcardShouldNotProceedWithTheSell
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook
		 withCreditCard:  
			instanceFactory  expiredCreditCard
		shouldRaiseAnErrorWithDescription: 
			CashierForSale cannotProccesSellForExpiredCreditCard! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630454!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook	
		 withCreditCard:  
			instanceFactory  creditCardWithoutFunds	
		shouldRaiseAnErrorWithDescription: 
			MerchantProcessorSimulator creditCardWithoutFundsErrorMessage
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:22:53' prior: 50630493!
test06robedCreditCardShouldNotProceedWithTheSell 
		self checkoutForCashier:  
				instanceFactory cashierWithACartWithABook		 
			withCreditCard:  
				instanceFactory  creditCardRobbed
				shouldRaiseAnErrorWithDescription: 
					MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard
	! !

!methodRemoval: CashierForSaleTest #xxxForCashier:withCreditCard:messageError: stamp: 'JB 6/10/2023 19:22:53'!
xxxForCashier: aCashier withCreditCard: aCreditCard messageError: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39'!
checkoutForCashier: aCashier withCreditCard: aCreditCard shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630560!
test04expiredCreditcardShouldNotProceedWithTheSell
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook
		 withCreditCard:  
			instanceFactory  expiredCreditCard
		shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: 
			CashierForSale cannotProccesSellForExpiredCreditCard! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630585!
test06robedCreditCardShouldNotProceedWithTheSell 
		self checkoutForCashier:  
				instanceFactory cashierWithACartWithABook		 
			withCreditCard:  
				instanceFactory  creditCardRobbed
				shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: 
					MerchantProcessorSimulator cannotProcessSaleForRobedCreditCard
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630572!
test05creditCardWithoutFundsShouldNotProceedWithTheSell 
		self checkoutForCashier:  
			instanceFactory cashierWithACartWithABook	
		 withCreditCard:  
			instanceFactory  creditCardWithoutFunds	
		shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: 
			MerchantProcessorSimulator creditCardWithoutFundsErrorMessage
	! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:24:39' prior: 50630549!
test01checkoutEmptyCartShouldRaiseAnError

	self checkoutForCashier: instanceFactory  cashierWithEmptyCart  withCreditCard: instanceFactory  validCreditCard  shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: CashierForSale cannotCheckoutEmptyCart! !

!methodRemoval: CashierForSaleTest #checkoutForCashier:withCreditCard:shouldRaiseAnErrorWithDescription: stamp: 'JB 6/10/2023 19:24:39'!
checkoutForCashier: aCashier withCreditCard: aCreditCard shouldRaiseAnErrorWithDescription: aBlock  
	|bookOfSells|
	bookOfSells := OrderedCollection  new. 
	self should: [
		aCashier   checkoutWhitCreditCard:  aCreditCard  registerOn: bookOfSells. 

		] 
	 raise: Error-MessageNotUnderstood  
	 
	  description: [:anError| 
		self assert:  anError messageText   equals:   aBlock .
		self assert:  		bookOfSells isEmpty 
		]!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:27:51' prior: 50627168!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: 500002) equals: bookOfSells ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:27:57' prior: 50630702!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:27:58'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:27:58'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:28:30' prior: 50627517!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection  with:  ammount ) equals:  bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:28:58' prior: 50630761!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: OrderedCollection new ).
	self assert: (OrderedCollection  with:  ammount ) equals:  bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:29:05' prior: 50630718!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: OrderedCollection new ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:28:30' prior: 50630778!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ).
	self assert: (OrderedCollection  with:  ammount ) equals:  bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:27:57' prior: 50630795!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:10'!
m1: cashier m2: bookOfSells m3: ammount

	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:10' prior: 50630829!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self m1: cashier m2: bookOfSells m3: ammount ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:33' prior: 50630812!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self  m1:  cashier  m2: ammount   m3: bookOfSells ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:30:34'!
ERROR!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:30:47' prior: 50630868!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount
	|cashier bookOfSells ammount|
	ammount :=  500003. 
	bookOfSells := OrderedCollection  new. 
	cashier := instanceFactory cashierWithACartWithTwoBooks. 
	
	
	self  m1:  cashier  m2: bookOfSells   m3: ammount ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:30:48'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:30:48'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:31:33' prior: 50630845!
m1: cashier m2: bookOfSells m3: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:32:08' prior: 50630856!
test02checkingOutCartWithAnElementShouldDoSomething
	|cashier bookOfSells ammount|
	ammount := 500002. 
	cashier := instanceFactory cashierWithACartWithABook. 
	bookOfSells := OrderedCollection  new. 
	
	self m1: instanceFactory cashierWithACartWithABook m2: OrderedCollection  new  m3: 500002 ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:16'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:16'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:32:20' prior: 50630934!
test02checkingOutCartWithAnElementShouldDoSomething

	self m1: instanceFactory cashierWithACartWithABook m2: OrderedCollection  new  m3: 500002 ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:21'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:21'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:32:52' prior: 50630884!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  m1:  instanceFactory cashierWithACartWithTwoBooks  m2: OrderedCollection  new   m3: 500003 ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:53'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:32:53'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:34:48'!
assertCheckingoutTheCashier: cashier affectsTheSalesBooks: bookOfSells anDebitTheAmmount: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:34:48' prior: 50630974!
test02checkingOutCartWithAnElementShouldDoSomething

	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook affectsTheSalesBooks: OrderedCollection  new  anDebitTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:34:48' prior: 50631009!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  assertCheckingoutTheCashier:  instanceFactory cashierWithACartWithTwoBooks  affectsTheSalesBooks: OrderedCollection  new   anDebitTheAmmount: 500003 ! !

!methodRemoval: CashierForSaleTest #m1:m2:m3: stamp: 'JB 6/10/2023 19:34:48'!
m1: cashier m2: bookOfSells m3: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:35:51' prior: 50630673!
test01checkoutEmptyCartShouldRaiseAnError

	self checkoutForCashier: instanceFactory  cashierWithEmptyCart  
		withCreditCard: instanceFactory  validCreditCard 
		 shouldNotProceedWithTheSellAndRaiseAnErrorWithDescription: CashierForSale cannotCheckoutEmptyCart! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:35:52'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:35:52'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:05' prior: 50631057!
test02checkingOutCartWithAnElementShouldDoSomething

	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
		 anDebitTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:06' prior: 50631126!
test02checkingOutCartWithAnElementShouldDoSomething

	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
			 anDebitTheAmmount: 500002 ! !

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:08'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:08'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:11' prior: 50631136!
test02checkingOutCartWithAnElementShouldDoSomething
	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
			 anDebitTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:22' prior: 50631067!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  assertCheckingoutTheCashier:  instanceFactory cashierWithACartWithTwoBooks 
		 affectsTheSalesBooks: OrderedCollection  new   
			anDebitTheAmmount: 500003 ! !

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:23'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:36:23'!
PASSED!
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:41'!
assertCheckingoutTheCashier: cashier affectsTheSalesBooks: bookOfSells anDebitsTheAmmount: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:41' prior: 50631173!
test02checkingOutCartWithAnElementShouldDoSomething
	self assertCheckingoutTheCashier: instanceFactory cashierWithACartWithABook 
		affectsTheSalesBooks: OrderedCollection  new 
			 anDebitsTheAmmount: 500002 ! !
!CashierForSaleTest methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:36:41' prior: 50631183!
test03checkingOutManyBooksShouldReturnTheCorrectAmmount	
	self  assertCheckingoutTheCashier:  instanceFactory cashierWithACartWithTwoBooks 
		 affectsTheSalesBooks: OrderedCollection  new   
			anDebitsTheAmmount: 500003 ! !

!methodRemoval: CashierForSaleTest #assertCheckingoutTheCashier:affectsTheSalesBooks:anDebitTheAmmount: stamp: 'JB 6/10/2023 19:36:41'!
assertCheckingoutTheCashier: cashier affectsTheSalesBooks: bookOfSells anDebitTheAmmount: ammount
	self assert:  ammount  equals:  (cashier  checkoutWhitCreditCard:  instanceFactory  validCreditCard registerOn: bookOfSells ). 
	self assert: (OrderedCollection  with: ammount ) equals: bookOfSells!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:39:12'!
crateCorrectlyDatedCashierForTheCart: aShoppingCart

	^ CashierForSale forTheShoppingCart: (aShoppingCart ) withDate: (GregorianMonthOfYear year: 2023   month: June ) debitSaleWithTheDebitator: MerchantProcessorSimulator new.! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:39:12' prior: 50626768!
cashierWithACartWithABook
	^self crateCorrectlyDatedCashierForTheCart:  (self createEmptyCart  add: self itemSellByTheStore ) ! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:39:12' prior: 50626782!
cashierWithACartWithTwoBooks
		|cart|
		cart := self createEmptyCart  add: self itemSellByTheStore. 
		cart add: 'Full Moon' . 


		^self crateCorrectlyDatedCashierForTheCart:  cart
 
 ! !
!InstanceFactory methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:39:12' prior: 50626799!
cashierWithEmptyCart
	^self crateCorrectlyDatedCashierForTheCart:  self createEmptyCart ! !

!methodRemoval: InstanceFactory #createCashierDatadForTheCart: stamp: 'JB 6/10/2023 19:39:12'!
createCashierDatadForTheCart: aShoppingCart

	^ CashierForSale forTheShoppingCart: (aShoppingCart ) withDate: (GregorianMonthOfYear year: 2023   month: June ) debitSaleWithTheDebitator: MerchantProcessorSimulator new.!

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:39:16'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:39:16'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:43:04' prior: 50629824!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].
		
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:05'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:05'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:43:43' prior: 50631334!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].		
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
					self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:44'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:43:44'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:43:48' prior: 50631371!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].		
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:44:29'!
checkForNoFunds: aCreditCard
	(aCreditCard  number = creditCardWithoutFunds number )ifTrue:[
				self error: self class creditCardWithoutFundsErrorMessage 
			].		
! !
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:44:48'!
checkForCrimes: aCreditCard
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:45:17' prior: 50631408!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	self checkForNoFunds:  aCreditCard .
	self checkForCrimes:  aCreditCard ! !

!testRun: #CashierForSaleTest #test01checkoutEmptyCartShouldRaiseAnError stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test02checkingOutCartWithAnElementShouldDoSomething stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test03checkingOutManyBooksShouldReturnTheCorrectAmmount stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test04expiredCreditcardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test05creditCardWithoutFundsShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:45:18'!
PASSED!

!testRun: #CashierForSaleTest #test06robedCreditCardShouldNotProceedWithTheSell stamp: 'JB 6/10/2023 19:45:18'!
PASSED!
!MerchantProcessorSimulator methodsFor: 'debit' stamp: 'JB 6/10/2023 19:45:55'!
checkForRobbedCreditCard: aCreditCard
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	! !
!MerchantProcessorSimulator methodsFor: 'as yet unclassified' stamp: 'JB 6/10/2023 19:45:55' prior: 50631438!
debitTheAmmount: anAmmount2debit toTheCreditCard: aCreditCard 
	self checkForNoFunds:  aCreditCard .
	self checkForRobbedCreditCard:  aCreditCard ! !

!methodRemoval: MerchantProcessorSimulator #checkForCrimes: stamp: 'JB 6/10/2023 19:45:55'!
checkForCrimes: aCreditCard
	(aCreditCard  number = stolenCreditCard number )ifTrue:[
				self error: self class  cannotProcessSaleForRobedCreditCard
				] 	!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:46:51'!
ERROR!
!CartTest methodsFor: 'support' stamp: 'JB 6/10/2023 19:47:04' prior: 50625749!
createCart
	
	^InstanceFactory  new  createEmptyCart  ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:47:05'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:47:33' prior: 50625674!
test01NewCartsAreCreatedEmpty

	self assert: self instanceFactory createEmptyCart  isEmpty! !

TestCase subclass: #CartTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: 'TusLibros' stamp: 'JB 6/10/2023 19:47:54'!
TestCase subclass: #CartTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'support' stamp: 'JB 6/10/2023 19:48:14' overrides: 16961394!
setUp
	instanceFactory  := InstanceFactory  new    ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:20'!
ERROR!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:48:20'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:20'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:48:38' prior: 50631548!
test01NewCartsAreCreatedEmpty

	self assert: instanceFactory  createEmptyCart  isEmpty! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:40'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:48:45'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:49:20' prior: 50625679!
test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [ cart add: self itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:49:38' prior: 50625692!
test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: self itemSellByTheStore.
	self deny: cart isEmpty ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:49:46'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:49:47'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:49:47'!
PASSED!

!methodRemoval: CartTest #createCart stamp: 'JB 6/10/2023 19:49:51'!
createCart
	
	^InstanceFactory  new  createEmptyCart  !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:49:56'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:49:56'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:49:56'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:49:56'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:50:43' prior: 50625700!
test04CanNotAddNonPositiveNumberOfItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [cart add: 0 of: instanceFactory  itemSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidQuantityErrorMessage.
			self assert: cart isEmpty ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:50:46'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:50:46'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:50:46'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:50:46'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:50:46'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:51:07' prior: 50625713!
test05CanNotAddMoreThanOneItemNotSellByTheStore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [cart add: 2 of: instanceFactory itemNotSellByTheStore  ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:51:08'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:51:08'!
ERROR!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:12'!
ERROR!
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:51:20'!
itemNotSellByTheStore
	self shouldBeImplemented.! !
!InstanceFactory methodsFor: 'category-name' stamp: 'JB 6/10/2023 19:51:45' prior: 50631790!
itemNotSellByTheStore
	^'Harry Potter :(' ! !

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:47'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:51:49'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:51:49'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:51:49'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:51:49'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:52:04' prior: 50625726!
test06CartRemembersAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: instanceFactory  itemSellByTheStore.
	self assert: (cart includes: self itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:05'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:06'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:06'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:06'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:52:20' prior: 50625734!
test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self deny: (cart includes: self itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:20'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:21'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:21'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:52:35' prior: 50625741!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: 2 of: self itemSellByTheStore.
	self assert: (cart occurrencesOf: self itemSellByTheStore) = 2! !

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:37'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:39'!
PASSED!

!methodRemoval: CartTest #defaultCatalog stamp: 'JB 6/10/2023 19:52:44'!
defaultCatalog
	|catalog| 
	catalog := Dictionary  new. 
	catalog add:( Association  key:  self itemSellByTheStore  value:  500002). 
	catalog add:( Association  key:  'Full Moon'   value:  1). 

	^ catalog!

!methodRemoval: CartTest #itemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:46'!
itemNotSellByTheStore
	
	^'invalidBook'!

!methodRemoval: CartTest #itemSellByTheStore stamp: 'JB 6/10/2023 19:52:48'!
itemSellByTheStore
	
	^ 'validBook'!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:52:53'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:52:53'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:52:53'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:52:53'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:06'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:06'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:06'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:06'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:06'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:09' prior: 50631632!
test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self 
		should: [ cart add: instanceFactory itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:11'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:11'!
ERROR!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:11'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:11'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:11'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:24' prior: 50631645!
test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: instanceFactory itemSellByTheStore.
	self deny: cart isEmpty ! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:25'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:25'!
ERROR!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:25'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:25'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:34' prior: 50631828!
test06CartRemembersAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: instanceFactory  itemSellByTheStore.
	self assert: (cart includes: instanceFactory itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:35'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:35'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:36'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:43' prior: 50631862!
test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	self deny: (cart includes: instanceFactory itemSellByTheStore)! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:53:44'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:53:45'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:53:45'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:53:45'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:45'!
ERROR!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:53:45'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:53:57' prior: 50631898!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: 2 of: instanceFactory itemSellByTheStore.
	self assert: (cart occurrencesOf: self itemSellByTheStore) = 2! !

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:54:01'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'JB 6/10/2023 19:54:11' prior: 50632147!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := instanceFactory  createEmptyCart .
	
	cart add: 2 of: instanceFactory itemSellByTheStore.
	self assert: (cart occurrencesOf: instanceFactory itemSellByTheStore) = 2! !

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:54:13'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JB 6/10/2023 19:54:18'!
PASSED!

----QUIT----(10 June 2023 20:08:27) CuisUniversity-5832.image priorSource: 9407797!

----STARTUP---- (10 June 2023 20:11:06) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


----QUIT----(10 June 2023 20:11:28) CuisUniversity-5832.image priorSource: 9617528!

----STARTUP---- (23 June 2023 18:11:57) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


!classRemoval: #MerchantProcessorSimulator stamp: 'JB 6/23/2023 18:12:11'!
Object subclass: #MerchantProcessorSimulator
	instanceVariableNames: 'creditCardWithoutFunds stolenCreditCard'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InstanceFactory stamp: 'JB 6/23/2023 18:12:11'!
Object subclass: #InstanceFactory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'JB 6/23/2023 18:12:11'!
Object subclass: #CreditCard
	instanceVariableNames: 'gregorianMonthOfYear date creditCardNumber expirationDate creditCardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierForSale stamp: 'JB 6/23/2023 18:12:12'!
Object subclass: #CashierForSale
	instanceVariableNames: 'cart date gregorianMonthOfYear creditCardDebitator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'JB 6/23/2023 18:12:12'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierForSaleTest stamp: 'JB 6/23/2023 18:12:12'!
TestCase subclass: #CashierForSaleTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'JB 6/23/2023 18:12:13'!
TestCase subclass: #CartTest
	instanceVariableNames: 'instanceFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\juanb\Desktop\facultad\1C23\IS1\git\2023-1c\10-CustomerImporter\CustomerImporter.st----!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:13:27'!
PASSED!
!Customer methodsFor: 'importing' stamp: 'JB 6/23/2023 18:16:04'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!methodRemoval: Customer class #importCustomers stamp: 'JB 6/23/2023 18:16:05'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:42'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:42'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:16:50' prior: 50632272!
test01Import

	Customer new importCustomers ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:55'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:16:56'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:18:06'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:18:26' prior: 50632627!
test01Import

	self importCustomers ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:18:27'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:18:28'!
PASSED!
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:20:38' prior: 50632636!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 18:21:20' prior: 50632686!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'JB 6/23/2023 18:21:21'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:30' prior: 50632726!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:39' overrides: 16961394!
setUp

	^ session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:39' prior: 50632773!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:48' prior: 50632819!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:21:54' prior: 50632813 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer)  beginTransaction! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:22:22' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:22:23' prior: 50632856!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:22:34' prior: 50632904!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:23:30' prior: 50632894 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:23:33'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:23:33'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:28:56' prior: 50632677!
test01Import

	self importCustomers .
	
	session  selectAllOfType:  Customer. ! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:31:07' prior: 50632988!
test01Import

	self importCustomers .
	
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:31:09'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/23/2023 18:31:09'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:31:24' prior: 50632994!
test01Import
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:32:01'!
test01ImportCustomersImportsTwoCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !

!methodRemoval: ImportTest #test01Import stamp: 'JB 6/23/2023 18:32:01'!
test01Import
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:32:27'!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:32:48'!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. ! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:32:50'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:32:51'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:32:51'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:32:52'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:33:53' prior: 50633023!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 
		(Set with: '' with: ''  )
	 equals: (session  selectAllOfType:  Customer). ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:33:55'!
FAILURE!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:37:24' prior: 50633051!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 
			 (session  select: [:aCustomer| 
				(aCustomer  firstName = 'Pepe' ) and: (aCustomer  lastName = 'Sanchez' )  
				]  ofType: Customer)   .! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:37:32'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:40:09' prior: 50633062!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self assert: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)   .! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:40:13'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:40:24'!
identifyAsNumber: aRenameMe1 ofType: aRenameMe2 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:40:44' prior: 50633087!
identifyAsNumber: aNumberOfIdentity ofType: aRenameMe2 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:40:53' prior: 50633092!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:41:49' prior: 50633098!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	(aNumberOfIdentity  = identificationNumber  ) and: (aNumberOfIdentity  =identificationType ).  ! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:41:52' prior: 50633104!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	(aNumberOfIdentity  = identificationNumber  ) and: (aNumberOfIdentity  =identificationType ).  ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:41:54'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:42:32' prior: 50633112!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity  = identificationNumber  ) and: (aNumberOfIdentity  =identificationType ).  ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:42:34'!
ERROR!

identificationNumber!

aNumberOfIdentity!

identificationNumber!

identificationType!

aNumberOfIdentity!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:43:20' prior: 50633123!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity  = identificationNumber  ) and: (tipeOfIdentity  =identificationType ).  ! !

tipeOfIdentity!

identificationNumber!

identificationType!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:44:00' prior: 50633138!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity  =  identificationNumber  ) and: (tipeOfIdentity  = identificationType ).  ! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 18:45:42' prior: 50632940!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:45:45'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:45:46'!
ERROR!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:45:47'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:45:47'!
ERROR!

aCustomer identifyAsNumber:'22333444' ofType: 'D' !

identificationNumber!

identificationType!

tipeOfIdentity!

identificationType!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 18:46:56' prior: 50633148!
identifyAsNumber: aNumberOfIdentity ofType: tipeOfIdentity 
	^(aNumberOfIdentity asUnicodeString   =  identificationNumber  ) and: (tipeOfIdentity asUnicodeString  = identificationType ).  ! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:46:59'!
ERROR!

identificationNumber!

aNumberOfIdentity asUnicodeString!

tipeOfIdentity asUnicodeString  = identificationType!

identificationNumber!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:48:53'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:49:50' prior: 50633075!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  .! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:49:52'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:49:53'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:49:54'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:49:54'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:50:00' prior: 50633229!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  .! !

 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  .!

a Customer!

self at: 1!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:52:10' prior: 50633251!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty  
			.! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:52:11'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:52:12'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:52:12'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:52:13'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:52:45' prior: 50633264!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:53:10' prior: 50633287!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:53:14'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:53:14'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:53:15'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:53:15'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:53:33' prior: 50633030!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:57:33' prior: 50633329!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	self assert: 
		2 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses  size) .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:57:36'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:57:37'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:57:38'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:57:38'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 18:58:15' prior: 50633334!
test03ImportCustomersImportsCorrectAdresses
	self importCustomers .
	self assert: 
		2 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses  size) .
	self assert: 
		1 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses  size) .
	
! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:58:18'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 18:58:19'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 18:58:20'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 18:58:20'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:04:01' prior: 50633363!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
"
	self assert: 
		2 equals: 
	
			 size) .
	self assert: 
		1 equals: 
	
			(( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses  size) .
	
"! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:11:09' prior: 50633393!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		addressOfPepe  select:[:anAddress |
			(anAddress  province = ' ')  and: 
				(anAddress  zipCode  = ''  and: 
					(anAddress  streetName  = ' ' and: 
						(anAddress  streetNumber  = ' ' and:  
							(anAddress  town = ''))))		
		]isEmpty ).! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:11:11'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:11:29' prior: 50633411!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		addressOfPepe  select:[:anAddress |
			(anAddress  province = ' ')  and: 
				(anAddress  zipCode  = ''  and: 
					(anAddress  streetName  = ' ' and: 
						(anAddress  streetNumber  = ' ' and:  
							(anAddress  town = ''))))		
		] isEmpty ).! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:11:45'!
ERROR!

addressOfPepe  select:[:anAddress |
			(anAddress  province = ' ')  and: 
				(anAddress  zipCode  = ''  and: 
					(anAddress  streetName  = ' ' and: 
						(anAddress  streetNumber  = ' ' and:  
							(anAddress  town = ''))))		
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:13:54' prior: 50633433!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = '1636'  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = '3322' and:  
							(anAddress  town = 'Olivos'))))		
		] isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:13:57'!
ERROR!

addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = '1636'  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = '3322' and:  
							(anAddress  town = 'Olivos'))))		
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:14:24' prior: 50633463!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = '1636'  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = '3322' and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:14:27'!
FAILURE!

anAddress!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:15:08' prior: 50633494!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:15:10'!
FAILURE!

anAddress!
!ImportTest methodsFor: 'import' stamp: 'JB 6/23/2023 19:16:03' prior: 50633156!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:16:06'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:16:07'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:16:08'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:17:27' prior: 50633518!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe |
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:17:32'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:17:32'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:17:33'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:17:34'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:18:15' prior: 50633588!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	

	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:19:14' prior: 50633639!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

	! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:19:16'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:19:16'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:19:17'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:19:18'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:29:51' prior: 50633682!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'BsAs')  and: 
				(anAddress  zipCode  = 1636  and: 
					(anAddress  streetName  = 'San Martin' and: 
						(anAddress  streetNumber  = 3322 and:  
							(anAddress  town = 'Olivos'))))		
		] )isEmpty ).
	" 
	
	self assert: addressOfPepe   hasAddress:  
		]
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

	"! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:29:55'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:29:55'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:29:56'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:29:57'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:32:32' prior: 50633739!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).
	" 
	
	self assert: addressOfPepe   hasAddress:  
		]
	self deny:( 
		(addressOfPepe  select:[:anAddress |
			(anAddress  province = 'Buenos Aires')  and: 
				(anAddress  zipCode  = 1122  and: 
					(anAddress  streetName  = 'Maipu' and: 
						(anAddress  streetNumber  = 888 and:  
							(anAddress  town = 'Florida'))))		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

	"! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:32:37'!
ERROR!
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:32:45'!
itsFromProvince: aRenameMe1 streetName: aRenameMe2 streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	self shouldBeImplemented.! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:33:17' prior: 50633842!
itsFromProvince: aRenameMe1 streetName: aRenameMe2 streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:33:19'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:33:19'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:33:20'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:33:21'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:35:37' prior: 50633797!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			(anAddress  province = 'CABA')  and: 
				(anAddress  zipCode  = 1001  and: 
					(anAddress  streetName  = 'Alem' and: 
						(anAddress  streetNumber  = 1122 and:  
							(anAddress  town = 'CABA'))))		
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:35:39'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:35:40'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:35:40'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:35:41'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:36:42' prior: 50633874!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode: 1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:36:43'!
FAILURE!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:36:50'!
FAILURE!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:37:12' prior: 50633925!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1001
			  town:  'CABA'
			  zipCode:  1122
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:37:14'!
FAILURE!

anAddress!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:38:28' prior: 50633968!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) addresses .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom) addresses .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:38:32'!
FAILURE!

(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )!

addressOfJuan!

addressOfJuan!

an Address!

anAddress!

anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001!
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:41:33' prior: 50633849!
itsFromProvince: aProvince streetName: aRenameMe2 streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:41:46' prior: 50634059!
itsFromProvince: aProvince streetName: anStreetName streetNumber: aRenameMe3 town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:41:54' prior: 50634071!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aRenameMe4 zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:42:01' prior: 50634083!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown zipCode: aRenameMe5 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:42:17' prior: 50634095!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown zipCode: aZipAddrress 
	^(  province = 'BsAs')  and: 
				(  zipCode  = 1636  and: 
					(  streetName  = 'San Martin' and: 
						(  streetNumber  = 3322 and:  
							(  town = 'Olivos'))))		! !
!Address methodsFor: 'testing' stamp: 'JB 6/23/2023 19:43:10' prior: 50634107!
itsFromProvince: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown zipCode: aZipCode 
	^(  province = aProvince )  and: 
				(  zipCode  = aZipCode  and: 
					(  streetName  = anStreetName and: 
						(  streetNumber  = anStreetNumber and:  
							(  town =  aTown ))))		! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:43:12'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 19:43:14'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 19:43:15'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 19:43:15'!
PASSED!

----SNAPSHOT----(23 June 2023 19:49:11) CuisUniversity-5832.image priorSource: 9617744!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:57:40' prior: 50633301!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
	
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:57:53'!
sessionHas

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:57:54' prior: 50634148!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
	
			 self sessionHas .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:58:57'!
sessionHas: anIdentityNumber

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 19:58:57' prior: 50634169!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
	
			 self sessionHas: '22333444' .
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !

!methodRemoval: ImportTest #sessionHas stamp: 'JB 6/23/2023 19:58:57'!
sessionHas

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  isEmpty!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 19:58:57' prior: 50634180!
sessionHas: anIdentityNumber

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: 'D' 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 19:59:40'!
sessionHas: anIdentityNumber identityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: 'D' 
				]  ofType: Customer)  isEmpty! !

!methodRemoval: ImportTest #sessionHas: stamp: 'JB 6/23/2023 19:59:40'!
sessionHas: anIdentityNumber

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: 'D' 
				]  ofType: Customer)  isEmpty!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 19:59:40' prior: 50634215!
sessionHas: anIdentityNumber identityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:00:09'!
sessionHasACustomerWithIdentityNumber: anIdentityNumber andIdentityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty! !

!methodRemoval: ImportTest #sessionHas:identityType: stamp: 'JB 6/23/2023 20:00:09'!
sessionHas: anIdentityNumber identityType: identityType 

	^ (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:01:29' prior: 50634188!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self deny: 
			(self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:01:33'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:01:34'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:01:34'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:01:35'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:01:42' prior: 50634260!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self assert: 
			(self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self deny: 
			 (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  isEmpty .
		
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:01:55' prior: 50634241!
sessionHasACustomerWithIdentityNumber: anIdentityNumber andIdentityType: identityType 

	^ ((session  select: [:aCustomer| 
				aCustomer identifyAsNumber:anIdentityNumber ofType: identityType 
				]  ofType: Customer)  isEmpty ) not! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:01:57'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:01:57'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:01:58'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:03:11' prior: 50634287!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self assert: 
			(self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )
			! !

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:03:13'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:03:14'!
PASSED!

!testRun: #ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:03:14'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:03:15'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:03:23' prior: 50634320!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	
	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:03:33' prior: 50634345!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:04:37'!
sessionHasCustomerPepeAndJuan

	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:04:37' prior: 50634357!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	self sessionHasCustomerPepeAndJuan
			! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:07:31' prior: 50634368!
sessionHasCustomerPepeAndJuan

	self assert: (self sessionHasACustomerWithIdentityNumber:     '22333444'  andIdentityType: 'D'). 
	self assert:  (self sessionHasACustomerWithIdentityNumber: '23-25666777-9'   andIdentityType:'C' )! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:08:58' prior: 50634378!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:09:03' prior: 50633011!
test01ImportCustomersImportsTwoCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. 
	self sessionHasCustomerPepeAndJuan
			! !

!methodRemoval: ImportTest #test02ImportCustomerImportCorrectCustomers stamp: 'JB 6/23/2023 20:09:06'!
test02ImportCustomerImportCorrectCustomers
	self importCustomers .

	!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:09:09'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:09:13'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:10:52' prior: 50634008!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:11:20' prior: 50634420!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan  addresses select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:37' prior: 50634455!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:59'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:59' prior: 50634491!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:13:37' prior: 50634535!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		] )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1: stamp: 'JB 6/23/2023 20:14:24'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:15:41'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:15:41' prior: 50634566!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:16:15'!
m1: addressOfPepe province: aProvince 

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:16:16' prior: 50634618!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1: stamp: 'JB 6/23/2023 20:16:16'!
m1: addressOfPepe

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  'BsAs' streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:16:16' prior: 50634649!
m1: addressOfPepe province: aProvince 

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:17:06'!
m1: addressOfPepe province: aProvince streetName: aStreetName  

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:06' prior: 50634659!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province: stamp: 'JB 6/23/2023 20:17:06'!
m1: addressOfPepe province: aProvince 

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: 'San Martin' streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:06' prior: 50634708!
m1: addressOfPepe province: aProvince streetName: aStreetName  

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:17:43'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: streetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:43' prior: 50634719!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName: stamp: 'JB 6/23/2023 20:17:43'!
m1: addressOfPepe province: aProvince streetName: aStreetName  

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  3322  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:17:44' prior: 50634771!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: streetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  streetNumber  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:18:02' prior: 50634827!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:18:31'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown    

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: 'Olivos'   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:18:31' prior: 50634783!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName:streetNumber: stamp: 'JB 6/23/2023 20:18:31'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber   

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: 'Olivos'   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:18:31' prior: 50634850!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown    

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:19:04'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:1636 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:19:04' prior: 50634863!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName:streetNumber:aTown: stamp: 'JB 6/23/2023 20:19:04'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown    

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:1636 
			
		]!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:19:04' prior: 50634921!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:20:06'!
aCustomer: addressOfPepe HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/23/2023 20:20:06' prior: 50634934!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!methodRemoval: ImportTest #m1:province:streetName:streetNumber:aTown:andZipCode: stamp: 'JB 6/23/2023 20:20:06'!
m1: addressOfPepe province: aProvince streetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:19:04' prior: 50635007!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self m1: addressOfPepe province: 'BsAs' streetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:21:57'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:20:06' prior: 50635056!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:22:19'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:22:43' prior: 50634993!
aCustomer: addressOfPepe HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ (addressOfPepe addresses)  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:22:45'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:22:45'!
ERROR!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:22:46'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:23:02' prior: 50635094!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(addressOfPepe addresses  select:[:anAddress |
			anAddress
			  itsFromProvince:  'Buenos Aires'
			  streetName:  'Maipu'
			  streetNumber:  888 
			  town:'Florida'
			  zipCode: 1122
			
		
		] )isEmpty ).
	

	
	self deny:( 
		(addressOfJuan addresses   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:23:10' prior: 50635132!
aCustomer: addressOfPepe HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ addressOfPepe addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:24:27' prior: 50635191!
aCustomer: aCustomer HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ aCustomer addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		]! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:28:38' prior: 50635156!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(self aCustomer:  addressOfPepe
		 HasAnAddressInTheprovince:   'Buenos Aires' 
		withStreetName: 'Maipu' 
		 streetNumber:  888
		aTown:  'Florida'
		andZipCode: 1122  ) isEmpty) .
	

	
	self deny:( 
		(addressOfJuan addresses   select:[:anAddress |
			anAddress
			  itsFromProvince:  'CABA'
			  streetName:'Alem'
			  streetNumber:  1122
			  town:  'CABA'
			  zipCode:   1001
			
			
		] )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:28:39'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:28:40'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:28:41'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:30:15' prior: 50635219!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 )isEmpty ).

	

	self deny:( 
		(self aCustomer:  addressOfPepe
		 HasAnAddressInTheprovince:   'Buenos Aires' 
		withStreetName: 'Maipu' 
		 streetNumber:  888
		aTown:  'Florida'
		andZipCode: 1122  ) isEmpty) .
	

	
	self deny:( 
		(self aCustomer:addressOfJuan 
		 HasAnAddressInTheprovince:  'CABA'
		withStreetName:'Alem'  
		streetNumber:  1122
		aTown:  'CABA'
		andZipCode: 1001  )isEmpty ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:16'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:30:16'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:17'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:21'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:30:22'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:30:23'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:30:57' prior: 50635205!
aCustomer: aCustomer HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ aCustomer 
			hasAnAddressThatitsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:31:00'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:31:00'!
ERROR!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:31:01'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 20:31:11'!
hasAnAddressThatitsFromProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode 
	self shouldBeImplemented.! !
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 20:32:53' prior: 50635339!
hasAnAddressThatitsFromProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode 
	^(addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode] isEmpty  not)  ! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:32:57'!
ERROR!
!Customer methodsFor: 'testing' stamp: 'JB 6/23/2023 20:33:25' prior: 50635347!
hasAnAddressThatitsFromProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode 
	^(addresses  select:[:anAddress |
			anAddress  itsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode] )isEmpty  not ! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:33:28'!
ERROR!
!ImportTest methodsFor: 'test' stamp: 'JB 6/23/2023 20:34:21' prior: 50635264!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self assert:( 
		(self aCustomer: addressOfPepe HasAnAddressInTheprovince: 'BsAs' withStreetName: 'San Martin' streetNumber: 3322 aTown: 'Olivos' andZipCode: 1636 ) ).

	

	self assert:( 
		(self aCustomer:  addressOfPepe
		 HasAnAddressInTheprovince:   'Buenos Aires' 
		withStreetName: 'Maipu' 
		 streetNumber:  888
		aTown:  'Florida'
		andZipCode: 1122  ) ) .
	

	
	self assert:( 
		(self aCustomer:addressOfJuan 
		 HasAnAddressInTheprovince:  'CABA'
		withStreetName:'Alem'  
		streetNumber:  1122
		aTown:  'CABA'
		andZipCode: 1001  ) ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:34:24'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/23/2023 20:34:26'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/23/2023 20:34:27'!
PASSED!

----QUIT----(23 June 2023 20:41:46) CuisUniversity-5832.image priorSource: 9679802!

----STARTUP---- (24 June 2023 12:00:34) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!

!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:04:27' prior: 50635379!
test03ImportCustomersImportsCorrectAdresses
	| addressOfPepe  addressOfJuan|
	self importCustomers .
	addressOfPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self assert:( 
		addressOfPepe  hasAnAddressThatitsFromProvince:  'BsAs'
		 streetName:  'San Martin'
		streetNumber: 3322
		 town: 'Olivos' 
		  zipCode: 1636).		
	

	self assert:( 
		addressOfPepe 
		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
	
	
		 ) .
	

	
	self assert:( 
		addressOfJuan  hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
		 ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:04:33'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:04:34'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:04:34'!
PASSED!

!methodRemoval: ImportTest #aCustomer:HasAnAddressInTheprovince:withStreetName:streetNumber:aTown:andZipCode: stamp: 'JB 6/24/2023 12:05:26'!
aCustomer: aCustomer HasAnAddressInTheprovince: aProvince withStreetName: aStreetName streetNumber: aStreetNumber aTown: aTown andZipCode: aZipCode     

	^ aCustomer 
			hasAnAddressThatitsFromProvince:  aProvince streetName: aStreetName streetNumber:  aStreetNumber  town: aTown   zipCode:aZipCode 
			
		!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:05:45' prior: 50635429!
test03ImportCustomersImportsCorrectAdresses
	| customerPepe  addressOfJuan|
	self importCustomers .
	customerPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	addressOfJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self assert:( 
		customerPepe  hasAnAddressThatitsFromProvince:  'BsAs'
		 streetName:  'San Martin'
		streetNumber: 3322
		 town: 'Olivos' 
		  zipCode: 1636).		
	

	self assert:( 
		customerPepe 
		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
	
	
		 ) .
	

	
	self assert:( 
		addressOfJuan  hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
		 ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:05:52' prior: 50635485!
test03ImportCustomersImportsCorrectAdresses
	| customerPepe  customerJuan|
	self importCustomers .
	customerPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	customerJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self assert:( 
		customerPepe  hasAnAddressThatitsFromProvince:  'BsAs'
		 streetName:  'San Martin'
		streetNumber: 3322
		 town: 'Olivos' 
		  zipCode: 1636).		
	

	self assert:( 
		customerPepe 
		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
	
	
		 ) .
	

	
	self assert:( 
		customerJuan  hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
		 ).

	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:09:59' prior: 50635516!
test03ImportCustomersImportsCorrectAdresses
	| customerPepe  customerJuan|
	self importCustomers .
	customerPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	customerJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
		

	self assert:( 
		customerPepe 
		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
	). 	

	
	self assert:( 
		customerJuan  hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
		 ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:10:01'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:10:02'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:10:03'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:11:03' prior: 50635547!
test03ImportCustomersImportsCorrectAdresses
	| customerPepe  customerJuan|
	self importCustomers .
	customerPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	customerJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	

	
	self assert:( 
		customerJuan  hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
		 ).

	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:11:07'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:11:08'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:11:09'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:11:33' prior: 50635590!
test03ImportCustomersImportsCorrectAdresses
	| customerPepe  customerJuan|
	self importCustomers .
	customerPepe := ( (session  select: [:aCustomer| 
				aCustomer identifyAsNumber:'22333444' ofType: 'D' 
				]  ofType: Customer)  atRandom) .
	customerJuan := ( (session  select: [:aCustomer| 
					aCustomer identifyAsNumber:'23-25666777-9' ofType: 'C' 
				]  ofType: Customer)  atRandom)  .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:11:36'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:11:37'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:11:38'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:11:47' prior: 50635635!
test03ImportCustomersImportsCorrectAdresses
	
	self importCustomers .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:11:51'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:11:52'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:11:53'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:12:12' prior: 50635682!
test03ImportCustomersImportsCorrectAdresses	
	
	self importCustomers .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:12:29' prior: 50635719!
test03ImportCustomersImportsCorrectAdresses	|var|
	var:=0.
	
	self importCustomers .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:12:35' prior: 50635746!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:12:38'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:12:39'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:12:40'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:13:51'!
xxx

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:13:51' prior: 50635774!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx. 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:14:18'!
xxx: aProvince

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:14:18' prior: 50635822!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs'. 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!methodRemoval: ImportTest #xxx stamp: 'JB 6/24/2023 12:14:18'!
xxx

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  'BsAs'
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:14:18' prior: 50635842!
xxx: aProvince

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:14:50'!
xxx: aProvince streetName: anStreetName 

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:14:50' prior: 50635853!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin'. 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!methodRemoval: ImportTest #xxx: stamp: 'JB 6/24/2023 12:14:50'!
xxx: aProvince

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  'San Martin'
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:14:50' prior: 50635894!
xxx: aProvince streetName: anStreetName 

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:15:28'!
xxx: aProvince streetName: anStreetName streetNumber: anStreetNumber  

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:15:28' prior: 50635906!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322. 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!methodRemoval: ImportTest #xxx:streetName: stamp: 'JB 6/24/2023 12:15:28'!
xxx: aProvince streetName: anStreetName 

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: 3322
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:15:28' prior: 50635949!
xxx: aProvince streetName: anStreetName streetNumber: anStreetNumber  

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: anStreetNumber
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:15:59'!
xxx: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown   

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: anStreetNumber
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:15:59' prior: 50635962!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos'. 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!methodRemoval: ImportTest #xxx:streetName:streetNumber: stamp: 'JB 6/24/2023 12:15:59'!
xxx: aProvince streetName: anStreetName streetNumber: anStreetNumber  

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: anStreetNumber
			 	town: 'Olivos' 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:15:59' prior: 50636009!
xxx: aProvince streetName: anStreetName streetNumber: anStreetNumber town: aTown   

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  anStreetName
				streetNumber: anStreetNumber
			 	town: aTown 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:16:07' prior: 50636059!
xxx: aProvince streetName: aStreetName streetNumber: anStreetNumber town: aTown   

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: anStreetNumber
			 	town: aTown 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:16:14' prior: 50636072!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown   

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:16:34'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode    

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:16:34' prior: 50636023!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636. 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer 		hasAnAddressThatitsFromProvince:  'Buenos Aires'
		 streetName:  'Maipu' 
		streetNumber:888
		  town:'Florida'
		  zipCode: 1122
  			]
		 ofType: Customer) isEmpty). 
	
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!methodRemoval: ImportTest #xxx:streetName:streetNumber:town: stamp: 'JB 6/24/2023 12:16:34'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown   

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: 1636
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:16:34' prior: 50636098!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode    

	^ self deny:( 
		(session  select:  [:aCustomer|
			aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:17:25' prior: 50636112!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636. 
	self xxx:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122.
		
	self deny:( 
		(session  select:  [:aCustomer|
			aCustomer hasAnAddressThatitsFromProvince:  'CABA'
		 streetName:  'Alem' 
		streetNumber:  1122
		town:  'CABA'
		zipCode: 1001
 		  			]
		 ofType: Customer) isEmpty). 


	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:17:27'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:17:28'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:17:29'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:18:09' prior: 50636162!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636. 
	self xxx:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122.
	self xxx: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001


	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:18:10'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:18:11'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:18:12'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:23:38' prior: 50636148!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode    

	| anIdentityNumber anIdentityType |
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber ofType: anIdentityType ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:25:08' prior: 50636216!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode    

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  '22333444'   ofType: 'D' ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:25:42'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode identityNumber: anIdentityNumber     

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  '22333444'   ofType: 'D' ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:25:42' prior: 50636191!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 identityNumber: '22333444'. 
	self xxx:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122 identityNumber: '22333444'.
	self xxx: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001 identityNumber: '22333444'


	

! !

!methodRemoval: ImportTest #xxx:streetName:streetNumber:town:zipCode: stamp: 'JB 6/24/2023 12:25:42'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode    

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  '22333444'   ofType: 'D' ) 
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:25:42' prior: 50636250!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode identityNumber: anIdentityNumber     

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber   ofType: 'D' ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:26:13'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode identityNumber: anIdentityNumber identityType: anIdentityType      

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber   ofType: 'D' ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:26:14' prior: 50636268!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 identityNumber: '22333444' identityType: 'D'. 
	self xxx:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122 identityNumber: '22333444' identityType: 'D'.
	self xxx: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001 identityNumber: '22333444' identityType: 'D'


	

! !

!methodRemoval: ImportTest #xxx:streetName:streetNumber:town:zipCode:identityNumber: stamp: 'JB 6/24/2023 12:26:14'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode identityNumber: anIdentityNumber     

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber   ofType: 'D' ) 
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:26:14' prior: 50636319!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode identityNumber: anIdentityNumber identityType: anIdentityType      

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber   ofType: anIdentityType ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:26:36' prior: 50636338!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self xxx: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 identityNumber: '22333444' identityType: 'D'. 
	self xxx:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122 identityNumber: '22333444' identityType: 'D'.
	self xxx: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001 identityNumber: '23-25666777-9' identityType: 'C'


	

! !

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:26:37'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:26:38'!
PASSED!

!testRun: #ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:26:39'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:28:06'!
isTheAddressLocatedInTheProvince: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode belongsToTheCustomerWIthIdentityNumber: anIdentityNumber identityType: anIdentityType      

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber   ofType: anIdentityType ) 
			]
		 ofType: Customer) isEmpty)! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:28:06' prior: 50636394!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self isTheAddressLocatedInTheProvince: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 belongsToTheCustomerWIthIdentityNumber: '22333444' identityType: 'D'. 
	self isTheAddressLocatedInTheProvince:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122 belongsToTheCustomerWIthIdentityNumber: '22333444' identityType: 'D'.
	self isTheAddressLocatedInTheProvince: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001 belongsToTheCustomerWIthIdentityNumber: '23-25666777-9' identityType: 'C'


	

! !

!methodRemoval: ImportTest #xxx:streetName:streetNumber:town:zipCode:identityNumber:identityType: stamp: 'JB 6/24/2023 12:28:06'!
xxx: aProvince streetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode identityNumber: anIdentityNumber identityType: anIdentityType      

	
	^ self deny:( 
		(session  select:  [:aCustomer|
			(aCustomer  hasAnAddressThatitsFromProvince:  aProvince
				streetName:  aStreetName
				streetNumber: aStreetNumber
			 	town: aTown 
			  	zipCode: aZipCode) and: (aCustomer identifyAsNumber:  anIdentityNumber   ofType: anIdentityType ) 
			]
		 ofType: Customer) isEmpty)!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:30:19'!
assertTheAddresesOfJuanAreInTheDataBase

	self isTheAddressLocatedInTheProvince: 'BsAs' streetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 belongsToTheCustomerWIthIdentityNumber: '22333444' identityType: 'D'. 
	self isTheAddressLocatedInTheProvince:  'Buenos Aires'  streetName: 'Maipu'    streetNumber:  888 town:  'Florida' zipCode: 1122 belongsToTheCustomerWIthIdentityNumber: '22333444' identityType: 'D'! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:30:19' prior: 50636444!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self assertTheAddresesOfJuanAreInTheDataBase.
	self isTheAddressLocatedInTheProvince: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001 belongsToTheCustomerWIthIdentityNumber: '23-25666777-9' identityType: 'C'


	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:30:41'!
assertTheAddressesOfPepeAreInTheDataBase

	^ self isTheAddressLocatedInTheProvince: 'CABA'   streetName: 'Alem'     streetNumber:  1122 town:  'CABA' zipCode: 	 1001 belongsToTheCustomerWIthIdentityNumber: '23-25666777-9' identityType: 'C'! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:30:41' prior: 50636504!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase


	

! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:30:55' prior: 50634399!
test01ImportCustomersImportsTwoCustomers
	self importCustomers .
	self assert: 2 equals: (session  selectAllOfType:  Customer) size. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !

!methodRemoval: ImportTest #test03ImportCustomersImportsCorrectAdresses stamp: 'JB 6/24/2023 12:30:59'!
test03ImportCustomersImportsCorrectAdresses	
	
	
	self importCustomers .


	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase


	

!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:31:02'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:31:35'!
assertSessionHasTwoCustomers

	^ self assert: 2 equals: (session  selectAllOfType:  Customer) size! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:31:35' prior: 50636537!
test01ImportCustomersImportsTwoCustomers
	self importCustomers .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:39:57'!
importCustomers: aStream

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:39:57' prior: 50636566!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: (UniFileStream new open: 'input.txt' forWrite: false) .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !

!methodRemoval: ImportTest #importCustomers stamp: 'JB 6/24/2023 12:39:57'!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	
	inputStream close.
!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 12:39:57' prior: 50636576!
importCustomers: aStream

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := aStream.
	

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	
	inputStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:41:17' prior: 50636661!
importCustomers: aStream

	"
	self importCustomers
	"
	| newCustomer line |

	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	aStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:41:53' prior: 50636696!
importCustomers: aStream

	
	| newCustomer line |

	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	aStream close.
! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:41:58'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 12:44:46' prior: 50636613!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: (self) .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:44:56' prior: 50636729!
importCustomers: aStream

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	aStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:45:05' prior: 50636776!
importCustomers: aStream

	
	| newCustomer line |
	aStream open. 
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	aStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:46:45' prior: 50636808!
importCustomers: aStream

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	aStream close.
! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 12:47:36' prior: 50636841!
importCustomers: aStream

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	"aStream close".
! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:48:28'!
ERROR!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 12:48:28'!
ERROR!
!ImportTest methodsFor: 'stream simulator' stamp: 'JB 6/24/2023 12:48:43'!
nextLine
	self shouldBeImplemented.! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'JB 6/24/2023 12:54:19'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session used'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'JB 6/24/2023 12:54:20'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session used lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'stream simulator' stamp: 'JB 6/24/2023 12:54:16' prior: 50636912!
nextLine
	used := used +1 . 
	^lines at: used.! !
!ImportTest methodsFor: 'set up' stamp: 'JB 6/24/2023 12:54:52' prior: 50632977 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction. 
	used  :=0. 
	lines:= OrderedCollection  new. ! !
!ImportTest methodsFor: 'set up' stamp: 'JB 6/24/2023 12:55:36' prior: 50636937 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction. 
	used  :=0. 
	lines := self initializeInput. ! !
!ImportTest methodsFor: 'stream private' stamp: 'JB 6/24/2023 12:55:54'!
initializeInput
	self shouldBeImplemented.! !
!ImportTest methodsFor: 'stream private' stamp: 'JB 6/24/2023 13:00:23' prior: 50636954!
initializeInput
	^OrderedCollection  
	with: 'C,Pepe,Sanchez,D,22333444'   
	with: 'A,San Martin,3322,Olivos,1636,BsAs'
	with:  'A,Maipu,888,Florida,1122,Buenos Aires'
	with:  'C,Juan,Perez,C,23-25666777-9'
	with:  'A,Alem,1122,CABA,1001,CABA'
	 
	




	! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:00:28'!
ERROR!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:00:28'!
ERROR!

lines!

used!
!ImportTest methodsFor: 'set up' stamp: 'JB 6/24/2023 13:01:37' prior: 50636946 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction. 
	used  :=0. 
	lines :=  ReadStream  on: self initializeInput. ! !

!methodRemoval: ImportTest #nextLine stamp: 'JB 6/24/2023 13:01:54'!
nextLine
	used := used +1 . 
	^lines at: used.!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 13:02:22' prior: 50636765!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: (lines ) .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:02:39'!
FAILURE!

line!

aStream!

aStream nextLine.!

aStream nextLine.!
!ImportTest methodsFor: 'stream private' stamp: 'JB 6/24/2023 13:04:40'!
nextLine
	^lines  next 

	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 13:04:47' prior: 50636990!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: (self ) .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:04:49'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:04:50'!
PASSED!
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 13:05:10' prior: 50636873!
importCustomers: aStream

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	! !
!ImportTest methodsFor: 'set up' stamp: 'JB 6/24/2023 13:05:26' prior: 50636978 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction. 
	
	lines :=  ReadStream  on: self initializeInput. ! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'JB 6/24/2023 13:05:36'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 13:08:18' prior: 50637027!
importCustomers: aStream

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			'jorge' persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	! !
!ImportTest methodsFor: 'import' stamp: 'JB 6/24/2023 13:08:43'!
importCustomers: aStream inSession: aSession 

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			'jorge' persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 13:08:43' prior: 50637010!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: (self ) inSession: 'jorge' .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !

!methodRemoval: ImportTest #importCustomers: stamp: 'JB 6/24/2023 13:08:43'!
importCustomers: aStream

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			'jorge' persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 13:08:43' prior: 50637107!
importCustomers: aStream inSession: aSession 

	
	| newCustomer line |
	
	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			aSession persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	
	! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 13:08:58' prior: 50637140!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: (self ) inSession: session .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:09:00'!
PASSED!

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:09:01'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 13:09:05' prior: 50637216!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: self  inSession: session .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase

! !
!ExtractToMethodObjectForm methodsFor: 'category-name' stamp: 'JB 6/24/2023 13:09:52'!
shouldAutoHighlight
	self shouldBeImplemented.! !
!ExtractToMethodObjectForm methodsFor: 'category-name' stamp: 'JB 6/24/2023 13:10:06' prior: 50637245!
shouldAutoHighlight
	^false! !

!classDefinition: #ImportCustomers category: 'CustomerImporter' stamp: 'JB 6/24/2023 13:13:17'!
Object subclass: #ImportCustomers
	instanceVariableNames: 'session stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportCustomers class methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 13:13:17'!
intoTheSession: anASession fromTheStream: anAStream
	^self new initializeIntoTheSession: anASession fromTheStream: anAStream! !
!ImportCustomers methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 13:13:18'!
initializeIntoTheSession: anASession fromTheStream: anAStream
	session := anASession.
	stream := anAStream.! !
!ImportCustomers methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 13:13:18'!
import 

	
	| newCustomer line |
	
	line := stream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth .
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := stream nextLine. ].

	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/24/2023 13:13:18' prior: 50637183!
importCustomers: aStream inSession: aSession
	(ImportCustomers intoTheSession: aSession fromTheStream: aStream) import! !

!testRun: #ImportTest #test01ImportCustomersImportsTwoCustomers stamp: 'JB 6/24/2023 13:13:44'!
PASSED!
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 13:15:57'!
assertTheAdressesBelongsToTheCustomers

	self assertTheAddresesOfJuanAreInTheDataBase.
	self assertTheAddressesOfPepeAreInTheDataBase! !
!ImportTest methodsFor: 'test' stamp: 'JB 6/24/2023 13:15:57' prior: 50637234!
test01ImportCustomersImportsTwoCustomers
	self importCustomers: self  inSession: session .
	self assertSessionHasTwoCustomers. 
	self sessionHasCustomerPepeAndJuan.
	self assertTheAdressesBelongsToTheCustomers

! !

----QUIT----(24 June 2023 13:16:28) CuisUniversity-5832.image priorSource: 9720669!

----STARTUP---- (28 June 2023 15:37:43) as C:\Users\juanb\Desktop\facultad\1C23\IS1\cuisUni\windows64\CuisUniversity-5832.image!


!classRemoval: #ImportCustomers stamp: 'JB 6/28/2023 15:37:54'!
Object subclass: #ImportCustomers
	instanceVariableNames: 'session stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #DataBaseSession stamp: 'JB 6/28/2023 15:37:55'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Customer stamp: 'JB 6/28/2023 15:37:55'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Address stamp: 'JB 6/28/2023 15:37:55'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #ImportTest stamp: 'JB 6/28/2023 15:37:56'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

----End fileIn of C:\Users\juanb\Desktop\facultad\1C23\IS1\git\ISW1-2023-1c\10-CustomerImporter\iteracion2\CustomerImporter-35.st----!

----End fileIn of C:\Users\juanb\Desktop\facultad\1C23\IS1\git\ISW1-2023-1c\10-CustomerImporter\iteracion2\CustomerImporter-35.st----!
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 15:48:48' prior: 50638088 overrides: 16902254!
value

	"
	self importCustomers
	"
	|  line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'JB 6/28/2023 15:48:49'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream newCustomer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 15:49:04' prior: 50638249 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'JB 6/28/2023 15:49:04'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream newCustomer line'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:51:06'!
importANewCustomerIfLineBeginsWithC

	^ (line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:51:06' prior: 50638291 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importANewCustomerIfLineBeginsWithC.

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:51:28'!
importNewAddressIfLineBeginsWithA

	^ (line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:51:28' prior: 50638349 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importANewCustomerIfLineBeginsWithC.

		self importNewAddressIfLineBeginsWithA.

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:52:36'!
importRecord

	self importANewCustomerIfLineBeginsWithC.

		self importNewAddressIfLineBeginsWithA! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:52:37' prior: 50638389 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importRecord.

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:52:51' prior: 50638406 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	
	[line := readStream nextLine. 
		line notNil ] whileTrue: [
		self importRecord.		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:52:52'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:52:53'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:53:29' prior: 50638415 overrides: 16902254!
value
	[	line := readStream nextLine. 
		line notNil ] whileTrue: [			self importRecord.		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:53:31'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:53:32'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:52:51' prior: 50638429 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	
	[line := readStream nextLine. 
		line notNil ] whileTrue: [
		self importRecord.		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:53:29' prior: 50638442 overrides: 16902254!
value
	[	line := readStream nextLine. 
		line notNil ] whileTrue: [			self importRecord.		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:52:51' prior: 50638451 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	
	[line := readStream nextLine. 
		line notNil ] whileTrue: [
		self importRecord.		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:52:37' prior: 50638459 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importRecord.

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:51:28' prior: 50638468 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importANewCustomerIfLineBeginsWithC.

		self importNewAddressIfLineBeginsWithA.

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:51:06' prior: 50638477 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importANewCustomerIfLineBeginsWithC.

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:49:04' prior: 50638489 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:54:45'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:55:16' prior: 50638512 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importANewCustomerIfLineBeginsWithC .
		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:55:17'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:55:30' prior: 50638548 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self importANewCustomerIfLineBeginsWithC .
		self importNewAddressIfLineBeginsWithA .
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:55:31'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:55:48' prior: 50638574 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
			self importRecord .
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:55:49'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:56:38' prior: 50638588 overrides: 16902254!
value
	line := readStream nextLine.
	[ line  ] whileNotNil: [
			self importRecord .
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:56:40'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:56:55' prior: 50638600 overrides: 16902254!
value
	
	[ line := readStream nextLine.
  ] whileNotNil: [
			self importRecord .
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:56:56'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:56:56'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:57:02' prior: 50638610 overrides: 16902254!
value
	
	[ line := readStream nextLine. line
  ] whileNotNil: [
			self importRecord .
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:57:03'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:57:04'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:57:18' prior: 50638623 overrides: 16902254!
value
	line := readStream nextLine.
	[ line  ] whileNotNil: [
			self importRecord .
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:57:20'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:55:48' prior: 50638636 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
			self importRecord .
		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:58:05' prior: 50638646 overrides: 16902254!
value
	[ line := readStream nextLine.
		line notNil ] whileTrue: [
			self importRecord .
		 ].

	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 15:58:07'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:59:49'!
thereIsAcustomerToAdd

	^ line beginsWith: 'A'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 15:59:49' prior: 50638371!
importNewAddressIfLineBeginsWithA

	^ (self thereIsAcustomerToAdd) ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:00:08'!
thereIsAnAddressToAdd

	^ line beginsWith: 'C'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:00:08' prior: 50638332!
importANewCustomerIfLineBeginsWithC

	^ (self thereIsAnAddressToAdd) ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:01:04'!
proccessImportData

	^ line findTokens: $,! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:01:04' prior: 50638691!
importANewCustomerIfLineBeginsWithC

	^ (self thereIsAnAddressToAdd) ifTrue: [ | customerData |
			customerData := self proccessImportData.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:01:04' prior: 50638669!
importNewAddressIfLineBeginsWithA

	^ (self thereIsAcustomerToAdd) ifTrue: [ | addressData newAddress |
			addressData := self proccessImportData.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:02:17'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:02:53'!
thereIsRecorsToImport

	line := readStream nextLine.
		line notNil! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:02:53' prior: 50638655 overrides: 16902254!
value
	[ self thereIsRecorsToImport ] whileTrue: [
			self importRecord .
		 ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:03:05' prior: 50638754 overrides: 16902254!
value
	[ self thereIsRecorsToImport ] whileTrue: [ self importRecord . ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:03:16'!
thereIsRecordsToImport

	line := readStream nextLine.
		line notNil! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:03:16' prior: 50638761 overrides: 16902254!
value
	[ self thereIsRecordsToImport ] whileTrue: [ self importRecord . ].

	! !

!methodRemoval: CustomerImporter #thereIsRecorsToImport stamp: 'JB 6/28/2023 16:03:16'!
thereIsRecorsToImport

	line := readStream nextLine.
		line notNil!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:05:13'!
importCustomer: customerData

	newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:05:13' prior: 50638712!
importANewCustomerIfLineBeginsWithC

	^ (self thereIsAnAddressToAdd) ifTrue: [ | customerData |
			customerData := self proccessImportData.
			self importCustomer: customerData ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:05:25' prior: 50638795!
importANewCustomerIfLineBeginsWithC

	^ (self thereIsAnAddressToAdd) ifTrue: [ self importCustomer: self proccessImportData ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:06:14' prior: 50638728!
importNewAddressIfLineBeginsWithA
|addressData|
addressData := self proccessImportData.

	^ (self thereIsAcustomerToAdd) ifTrue: [ |  newAddress |
			
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:06:25'!
importAddress: addressData

	|  newAddress |
			
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:06:26' prior: 50638811!
importNewAddressIfLineBeginsWithA
|addressData|
addressData := self proccessImportData.

	^ (self thereIsAcustomerToAdd) ifTrue: [ self importAddress: addressData ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:06:36' prior: 50638843!
importNewAddressIfLineBeginsWithA
^ (self thereIsAcustomerToAdd) ifTrue: [ self importAddress: self proccessImportData ]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:06:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:06:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:06:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:06:46'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:07:06' prior: 50638766!
thereIsRecordsToImport

	line := readStream nextLine.
		^line notNil! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:07:07'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:07:13'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:07:15'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:08:22' prior: 50638399!
importRecord
 'JB : No se me ocurre mejor nombre medio que viola encapsulamiento' 
	self importANewCustomerIfLineBeginsWithC.

		self importNewAddressIfLineBeginsWithA! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:08:36' prior: 50638882!
importRecord
 "JB : No se me ocurre mejor nombre medio que viola encapsulamiento" 
	self importANewCustomerIfLineBeginsWithC.

		self importNewAddressIfLineBeginsWithA! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:08:38'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:09:18'!
importANewCustomerIfItsACustomerRecord

	^ (self thereIsAnAddressToAdd) ifTrue: [ self importCustomer: self proccessImportData ]! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:09:18' prior: 50638891!
importRecord
 "JB : No se me ocurre mejor nombre medio que viola encapsulamiento" 
	self importANewCustomerIfItsACustomerRecord.

		self importNewAddressIfLineBeginsWithA! !

!methodRemoval: CustomerImporter #importANewCustomerIfLineBeginsWithC stamp: 'JB 6/28/2023 16:09:18'!
importANewCustomerIfLineBeginsWithC

	^ (self thereIsAnAddressToAdd) ifTrue: [ self importCustomer: self proccessImportData ]!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:09:39'!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAcustomerToAdd) ifTrue: [ self importAddress: self proccessImportData ]! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:09:39' prior: 50638910!
importRecord
 "JB : No se me ocurre mejor nombre medio que viola encapsulamiento" 
	self importANewCustomerIfItsACustomerRecord.

		self importNewAddressIfItsAnAddressRecord! !

!methodRemoval: CustomerImporter #importNewAddressIfLineBeginsWithA stamp: 'JB 6/28/2023 16:09:39'!
importNewAddressIfLineBeginsWithA
^ (self thereIsAcustomerToAdd) ifTrue: [ self importAddress: self proccessImportData ]!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:09:46' prior: 50638934!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:09:48'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:10:18'!
thereIsAnAddressToImport

	^ line beginsWith: 'C'! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:10:18' prior: 50638902!
importANewCustomerIfItsACustomerRecord

	^ (self thereIsAnAddressToImport) ifTrue: [ self importCustomer: self proccessImportData ]! !

!methodRemoval: CustomerImporter #thereIsAnAddressToAdd stamp: 'JB 6/28/2023 16:10:18'!
thereIsAnAddressToAdd

	^ line beginsWith: 'C'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:10:37'!
thereIsAcustomerToImport

	^ line beginsWith: 'A'! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:10:37' prior: 50638926!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAcustomerToImport) ifTrue: [ self importAddress: self proccessImportData ]! !

!methodRemoval: CustomerImporter #thereIsAcustomerToAdd stamp: 'JB 6/28/2023 16:10:37'!
thereIsAcustomerToAdd

	^ line beginsWith: 'A'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:11:30'!
thereIsACustomerToImport

	^ line beginsWith: 'C'! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:11:31' prior: 50638964!
importANewCustomerIfItsACustomerRecord

	^ (self thereIsACustomerToImport) ifTrue: [ self importCustomer: self proccessImportData ]! !

!methodRemoval: CustomerImporter #thereIsAnAddressToImport stamp: 'JB 6/28/2023 16:11:31'!
thereIsAnAddressToImport

	^ line beginsWith: 'C'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'JB 6/28/2023 16:11:55'!
thereIsAnAddressToImport

	^ line beginsWith: 'A'! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:11:55' prior: 50638980!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport) ifTrue: [ self importAddress: self proccessImportData ]! !

!methodRemoval: CustomerImporter #thereIsAcustomerToImport stamp: 'JB 6/28/2023 16:11:55'!
thereIsAcustomerToImport

	^ line beginsWith: 'A'!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:11:57'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:15:04'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:18:40'!
test02

	CustomerImporter valueFrom: self validImportData into: session..

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:18:42'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:18:43'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:18:44'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:18:47'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:18:48'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:18:49'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:24:59' prior: 50639029!
test02

	CustomerImporter valueFrom: nil into: session..

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:25:46' prior: 50639052!
test02
	CustomerImporter valueFrom: nil into: session..
! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:25:53' prior: 50639061!
test02
	CustomerImporter valueFrom: self nilImportData into: session..
! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:29:19' prior: 50639066!
test02	|aCustomerImporter|
	self should: [
			aCustomerImporter := CustomerImporter valueFrom: self nilImportData into: session. 		
		] raise: Error 
		withExceptionDo: [:anError|
			self assert: CustomerImporter  nilStreamErrorMessage  equals: anError messageText .
			self assert:  aCustomerImporter  isNil.  
			
		]


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:30:55' prior: 50639071!
test02
	self should: [
			 CustomerImporter valueFrom: self nilImportData into: session. 		
		] raise: Error 
		withExceptionDo: [:anError|
			self assert: CustomerImporter  nilStreamErrorMessage  equals: anError messageText .
			self assert:  (session  selectAllOfType: Customer) isEmpty  .  
			
		]


! !

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:31:00'!
ERROR!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 16:31:18'!
nilStreamErrorMessage
	self shouldBeImplemented.! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 16:31:51' prior: 50639099!
nilStreamErrorMessage
	^'cannot import with  a  nil imput stream' ! !

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:31:53'!
FAILURE!

self nilImportData!
!ImportTest methodsFor: 'test data' stamp: 'JB 6/28/2023 16:32:05'!
nilImportData
	self shouldBeImplemented.! !
!ImportTest methodsFor: 'test data' stamp: 'JB 6/28/2023 16:32:13' prior: 50639112!
nilImportData
	^nil! !

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:32:19'!
FAILURE!

anError messageText!

anError!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:32:55'!
FAILURE!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:33:00'!
FAILURE!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'JB 6/28/2023 16:34:27' prior: 50638130!
from: aReadStream into: aSession	aReadStream  ifNil:  [
		self error: self class  nilStreamErrorMessage  
		].


	^self new initializeFrom: aReadStream into: aSession! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:34:29'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:34:29'!
FAILURE!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:34:29'!
FAILURE!

anError messageText!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'JB 6/28/2023 16:35:05' prior: 50639128!
from: aReadStream into: aSession	aReadStream  ifNil:  [
		self error: self class nilStreamErrorMessage  
		].


	^self new initializeFrom: aReadStream into: aSession! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'JB 6/28/2023 16:35:13' prior: 50639145!
from: aReadStream into: aSession	aReadStream  ifNil:  [
		self error: self  nilStreamErrorMessage  
		].


	^self new initializeFrom: aReadStream into: aSession! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:35:15'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'JB 6/28/2023 16:35:15'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:35:49'!
test02importWithNilDataRaisesAnError
	self should: [
			 CustomerImporter valueFrom: self nilImportData into: session. 		
		] raise: Error 
		withExceptionDo: [:anError|
			self assert: CustomerImporter  nilStreamErrorMessage  equals: anError messageText .
			self assert:  (session  selectAllOfType: Customer) isEmpty  .  
			
		]


! !

!methodRemoval: ImportTest #test02 stamp: 'JB 6/28/2023 16:35:49'!
test02
	self should: [
			 CustomerImporter valueFrom: self nilImportData into: session. 		
		] raise: Error 
		withExceptionDo: [:anError|
			self assert: CustomerImporter  nilStreamErrorMessage  equals: anError messageText .
			self assert:  (session  selectAllOfType: Customer) isEmpty  .  
			
		]


!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:36:38'!
test03

			 CustomerImporter valueFrom:  ''  into: session. 		
			self assert:  (session  selectAllOfType: Customer) isEmpty  .  


! !

!testRun: #ImportTest #test03 stamp: 'JB 6/28/2023 16:36:39'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:37:15'!
isSessionEmpty

	^ (session  selectAllOfType: Customer) isEmpty! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:37:15' prior: 50639166!
test02importWithNilDataRaisesAnError
	self should: [
			 CustomerImporter valueFrom: self nilImportData into: session. 		
		] raise: Error 
		withExceptionDo: [:anError|
			self assert: CustomerImporter  nilStreamErrorMessage  equals: anError messageText .
			self assert:  self isSessionEmpty  .  
			
		]


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:37:15' prior: 50639191!
test03

			 CustomerImporter valueFrom:  ''  into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!testRun: #ImportTest #test03 stamp: 'JB 6/28/2023 16:37:22'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:37:48' prior: 50639218!
test03

			 CustomerImporter valueFrom:  '' into: session. 		
			self assert:  self isSessionEmpty  .  


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:38:14' prior: 50639227!
test03

			 CustomerImporter valueFrom: ( ReadStream  on:  '')  into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!testRun: #ImportTest #test03 stamp: 'JB 6/28/2023 16:38:16'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:38:16'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:38:17'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'JB 6/28/2023 16:38:17'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:38:28'!
importEmptyData

	^ ReadStream  on:  ''! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:38:28' prior: 50639233!
test03

			 CustomerImporter valueFrom: ( self importEmptyData)  into: session. 		
			self assert:  self isSessionEmpty  .  


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:38:36' prior: 50639254!
test03

			 CustomerImporter valueFrom: self importEmptyData into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!testRun: #ImportTest #test03 stamp: 'JB 6/28/2023 16:38:37'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:38:38'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:38:38'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'JB 6/28/2023 16:38:38'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:39:03'!
test03importEmptyDataShouldNotModifySession

			 CustomerImporter valueFrom: self importEmptyData into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!methodRemoval: ImportTest #test03 stamp: 'JB 6/28/2023 16:39:03'!
test03

			 CustomerImporter valueFrom: self importEmptyData into: session. 		
			self assert:  self isSessionEmpty  .  


!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:39:08'!
test04

			 CustomerImporter valueFrom: self importEmptyData into: session. 		
			self assert:  self isSessionEmpty  .  


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:39:32' prior: 50639292!
test04

			 CustomerImporter valueFrom: ( ReadStream  on: '
			')  into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!testRun: #ImportTest #test04 stamp: 'JB 6/28/2023 16:39:33'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:39:34'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:39:34'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:39:34'!
PASSED!

!testRun: #ImportTest #test04 stamp: 'JB 6/28/2023 16:39:34'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:40:16'!
test04importDataTabShouldNotModifySession

	^ ReadStream  on: '
			'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:40:17' prior: 50639299!
test04

			 CustomerImporter valueFrom: ( self test04importDataTabShouldNotModifySession)  into: session. 		
			self assert:  self isSessionEmpty  .  


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:40:26' prior: 50639324!
test04

			 CustomerImporter valueFrom:  self test04importDataTabShouldNotModifySession into: session. 		
			self assert:  self isSessionEmpty  .  


! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:40:39'!
importDataTabString

	^ ReadStream  on: '
			'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:40:39' prior: 50639332!
test04

			 CustomerImporter valueFrom:  self importDataTabString into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!methodRemoval: ImportTest #test04importDataTabShouldNotModifySession stamp: 'JB 6/28/2023 16:40:39'!
test04importDataTabShouldNotModifySession

	^ ReadStream  on: '
			'!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:40:43'!
test04importDataTabShouldNotModifySession

			 CustomerImporter valueFrom:  self importDataTabString into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!methodRemoval: ImportTest #test04 stamp: 'JB 6/28/2023 16:40:44'!
test04

			 CustomerImporter valueFrom:  self importDataTabString into: session. 		
			self assert:  self isSessionEmpty  .  


!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:41:16' prior: 50639339!
importDataTabString

	^ ReadStream  on: '
	'! !
!ImportTest methodsFor: 'test data' stamp: 'JB 6/28/2023 16:41:33' prior: 50639371!
importDataTabString

	^ ReadStream  on: '	'! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:41:34'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:41:35'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:41:35'!
PASSED!

!testRun: #ImportTest #test04importDataTabShouldNotModifySession stamp: 'JB 6/28/2023 16:41:35'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'JB 6/28/2023 16:41:41' prior: 50639376!
importDataTabString

	^ ReadStream  on: '
	'! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:41:50'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:41:50'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:41:50'!
PASSED!

!testRun: #ImportTest #test04importDataTabShouldNotModifySession stamp: 'JB 6/28/2023 16:41:51'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'JB 6/28/2023 16:43:40'!
importDataLineJump

	^ ReadStream  on: '
	'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 16:43:40' prior: 50639356!
test04importDataTabShouldNotModifySession

			 CustomerImporter valueFrom:  self importDataLineJump into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!methodRemoval: ImportTest #importDataTabString stamp: 'JB 6/28/2023 16:43:40'!
importDataTabString

	^ ReadStream  on: '
	'!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:43:53'!
test04importDataWithALineJumpShouldNotModifySession

			 CustomerImporter valueFrom:  self importDataLineJump into: session. 		
			self assert:  self isSessionEmpty  .  


! !

!methodRemoval: ImportTest #test04importDataTabShouldNotModifySession stamp: 'JB 6/28/2023 16:43:54'!
test04importDataTabShouldNotModifySession

			 CustomerImporter valueFrom:  self importDataLineJump into: session. 		
			self assert:  self isSessionEmpty  .  


!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:43:55'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:43:56'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:43:56'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:43:56'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:43:57'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:43:58'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:43:59'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:43:59'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:43:59'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:43:59'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:47:12'!
test05	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on:  ' ' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithotCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:48:05' prior: 50639475!
test05	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on:  ' ' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 16:48:23' prior: 50639488!
test05	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on:  'A,San Martin,3322,Olivos,1636,BsAs' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:48:25'!
ERROR!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 16:48:34'!
cannotImportAddressWithoutCustomer
	self shouldBeImplemented.! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 16:49:04' prior: 50639517!
cannotImportAddressWithoutCustomer
	 ^'cannot import an address without a previuos imported customer'! !

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:49:06'!
FAILURE!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:49:22'!
FAILURE!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'JB 6/28/2023 16:51:38'!
checkForNilStream: aReadStream

	^ aReadStream  ifNil:  [
		self error: self  nilStreamErrorMessage  
		]! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'JB 6/28/2023 16:51:38' prior: 50639154!
from: aReadStream into: aSession	self checkForNilStream: aReadStream.


	^self new initializeFrom: aReadStream into: aSession! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'JB 6/28/2023 16:52:30' prior: 50639541!
from: aReadStream into: aSession	self checkForNilStream: aReadStream. 
	^self new initializeFrom: aReadStream into: aSession! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:55:03' prior: 50639013!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport and: (newCustomer  isNil not ) ) ifTrue: [ 
	
	self importAddress: self proccessImportData ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:56:06' prior: 50639556!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(newCustomer  isNil   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]
]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:56:08'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:56:08'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:56:08'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:56:08'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:56:08'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:56:27'!
thereWasACustomerImportedBefore

	^ newCustomer  isNil! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:56:27' prior: 50639565!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]
]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:57:15' prior: 50639596!
importNewAddressIfItsAnAddressRecord
|aBlock|
aBlock  := self importAddress: self proccessImportData . 

^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				aBlock  value]
]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:57:31' prior: 50639608!
importNewAddressIfItsAnAddressRecord
|aBlock|
aBlock  := self importAddress: self proccessImportData . 

^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				aBlock  value
				]
]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:57:32'!
ERROR!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:57:32'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:57:32'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:57:32'!
ERROR!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:57:32'!
FAILURE!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:56:27' prior: 50639621!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]
]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:57:52'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:57:52'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:57:52'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:57:52'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:57:52'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:58:41' prior: 50639649!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]
]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:58:49'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:58:49'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:58:49'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:58:49'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:58:50'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:58:57' prior: 50639676!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]
]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 16:58:59'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 16:58:59'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 16:58:59'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 16:59:00'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 16:59:00'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:59:22' prior: 50639703!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	[(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]] value
]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:59:46'!
importNewAddressIfThereWasACustomerimportedBefore

	^ [(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:59:46' prior: 50639730!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	self importNewAddressIfThereWasACustomerimportedBefore value
]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 16:59:51' prior: 50639753!
importNewAddressIfItsAnAddressRecord
^ (self thereIsAnAddressToImport ) ifTrue: [ 
	self importNewAddressIfThereWasACustomerimportedBefore 
]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:00:02' prior: 50639742!
importNewAddressIfThereWasACustomerimportedBefore

	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
				self importAddress: self proccessImportData ]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:00:03'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:00:04'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:00:04'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:00:04'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 17:00:04'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:01:06'!
importDataOnlyAnAdress

	^ ReadStream on:  'A,San Martin,3322,Olivos,1636,BsAs'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:01:06' prior: 50639501!
test05	self  should:  [
		CustomerImporter valueFrom:  (self importDataOnlyAnAdress ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:01:11' prior: 50639800!
test05	self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 17:01:12'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:01:12'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:01:13'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:01:13'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:01:13'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'JB 6/28/2023 17:01:13'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:01:45'!
test05importAnAddressBeforACustomerShouldRaiseAnError	self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !

!methodRemoval: ImportTest #test05 stamp: 'JB 6/28/2023 17:01:45'!
test05	self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:01:46'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:01:47'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:01:47'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:01:47'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:01:47'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:01:48'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:01:54'!
test06	self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:10:09' prior: 50639888!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: ' ' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:10:50' prior: 50639901!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:10:54' prior: 50639914!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:10:58' prior: 50639930!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:11:29' prior: 50639946!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:12:58' prior: 50639962!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				self assert:  self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:13:00'!
ERROR!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 17:13:07'!
notEnoughDataInCustomerToImport
	self shouldBeImplemented.! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 17:13:45' prior: 50639997!
notEnoughDataInCustomerToImport
	^'The customer data wasnt suficient to be imported in the data base' ! !

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:13:47'!
FAILURE!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:20:00' prior: 50638996!
importANewCustomerIfItsACustomerRecord

	^ (self thereIsACustomerToImport) ifTrue: [
		|dataToImport| 
		dataToImport:= self proccessImportData. 
		 (dataToImport  size = 5 )ifTrue: [
				self error: self class notEnoughDataInCustomerToImport 
			]ifFalse: [
				 self importCustomer:  dataToImport  ]
	
	]
! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:20:02'!
ERROR!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:20:02'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:20:02'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:20:02'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:20:02'!
PASSED!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:20:02'!
ERROR!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:20:41' prior: 50640012!
importANewCustomerIfItsACustomerRecord

	^ (self thereIsACustomerToImport) ifTrue: [
		|dataToImport| 
		dataToImport:= self proccessImportData. 
		 (dataToImport  size = 5 )ifFalse: [
				self error: self class notEnoughDataInCustomerToImport 
			]ifTrue:  [
				 self importCustomer:  dataToImport  ]
	
	]
! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:20:43'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:20:43'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:20:43'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:20:43'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:20:43'!
PASSED!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:20:44'!
ERROR!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:20:44'!
ERROR!

session!

a Customer!

aCustomer!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:22:51'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:22:51'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:22:51'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:22:51'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:22:51'!
PASSED!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:22:52'!
ERROR!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:22:52'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:23:03' prior: 50639978!
test06	self  should:  [
		CustomerImporter valueFrom:  (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:23:06'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:23:08'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:23:09'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:23:09'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:23:09'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:23:09'!
PASSED!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:23:09'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:26:19'!
importDataIfTheRecordIsOfTheCorrectLenght

	|dataToImport| 
		dataToImport:= self proccessImportData. 
		 (dataToImport  size = 5 )ifFalse: [
				self error: self class notEnoughDataInCustomerToImport 
			]ifTrue:  [
				 self importCustomer:  dataToImport  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:26:20' prior: 50640044!
importANewCustomerIfItsACustomerRecord

	^ (self thereIsACustomerToImport) ifTrue: [
		self importDataIfTheRecordIsOfTheCorrectLenght
	
	]
! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:26:24'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:26:24'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:26:24'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:26:24'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:26:24'!
PASSED!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:26:25'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:27:01'!
invalidDataWrongSizeCustomer

	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:27:01' prior: 50640099!
test06	self  should:  [
		CustomerImporter valueFrom:  (self invalidDataWrongSizeCustomer ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:27:08' prior: 50640181!
test06	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:27:09'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:27:10'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:27:11'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:27:11'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:27:11'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:27:11'!
PASSED!

!testRun: #ImportTest #test06 stamp: 'JB 6/28/2023 17:27:11'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:27:48'!
test06importDataWithWrongSizedCustomerRecordShouldRaisAnError	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!methodRemoval: ImportTest #test06 stamp: 'JB 6/28/2023 17:27:48'!
test06	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:27:56'!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!methodRemoval: ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaisAnError stamp: 'JB 6/28/2023 17:27:56'!
test06importDataWithWrongSizedCustomerRecordShouldRaisAnError	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:28:02'!
test07	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:28:21' prior: 50640284!
test07	self  should:  [
		CustomerImporter valueFrom:  (ReadStream  on: '' )  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:28:48' prior: 50640297!
test07	self  should:  [
		CustomerImporter valueFrom:  (ReadStream  on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001' )  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInCustomerToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:29:11' prior: 50640310!
test07	self  should:  [
		CustomerImporter valueFrom:  (ReadStream  on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001' )  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataInAddressToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:29:14'!
ERROR!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 17:29:20'!
notEnoughDataInAddressToImport
	self shouldBeImplemented.! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 17:29:46' prior: 50640347!
notEnoughDataInAddressToImport
	^'The data Adrress wasnt  suficient to import' ! !

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:29:47'!
FAILURE!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:31:53' prior: 50639769!
importNewAddressIfThereWasACustomerimportedBefore

	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
		|addressData|
			addressData  := self  proccessImportData  . 
			 (addressData  size = 6 ) ifFalse :[
				self error: self class notEnoughDataInAddressToImport 
				]
				 ifTrue:[
		
				self importAddress: addressData  ]
			]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:32:03' prior: 50640361!
importNewAddressIfThereWasACustomerimportedBefore

	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
		|addressData|
			addressData  := self  proccessImportData  . 
			 (addressData  size = 6 ) ifFalse:[
				self error: self class notEnoughDataInAddressToImport 
				]
				 ifTrue:[
		
				self importAddress: addressData  ]
			]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:32:06'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:32:06'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:32:06'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:32:06'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:32:06'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:32:07'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:32:07'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:33:49'!
importAddressIfTheRecordIsOfTheCorrectLenght

	|addressData|
			addressData  := self  proccessImportData  . 
			 (addressData  size = 6 ) ifFalse:[
				self error: self class notEnoughDataInAddressToImport 
				]
				 ifTrue:[
		
				self importAddress: addressData  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:33:50' prior: 50640377!
importNewAddressIfThereWasACustomerimportedBefore

	(self thereWasACustomerImportedBefore   ) ifTrue: [
		self error:  self class cannotImportAddressWithoutCustomer  
		] ifFalse: [ 
		self importAddressIfTheRecordIsOfTheCorrectLenght
			]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:35:02' prior: 50640415!
importAddressIfTheRecordIsOfTheCorrectLenght

	|dataToImport|
			dataToImport  := self  proccessImportData  . 
			 (dataToImport  size = 6 ) ifFalse:[
				self error: self class notEnoughDataInAddressToImport 
				]
				 ifTrue:[
		
				self importAddress: dataToImport  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:37:06' prior: 50640438!
importAddressIfTheRecordIsOfTheCorrectLenght

	|dataToImport|
			dataToImport  := self  proccessImportData  . 
			 (dataToImport  size = 6 ) ifFalse:[
				self error: self class notEnoughDataInCustomerToImport 
				]
				 ifTrue:[
		
				self importAddress: dataToImport  ]! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 17:37:18'!
notEnoughDataToImport
	^'The customer data wasnt suficient to be imported in the data base' ! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 17:37:18' prior: 50640136!
importDataIfTheRecordIsOfTheCorrectLenght

	|dataToImport| 
		dataToImport:= self proccessImportData. 
		 (dataToImport  size = 5 )ifFalse: [
				self error: self class notEnoughDataToImport 
			]ifTrue:  [
				 self importCustomer:  dataToImport  ]! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 17:37:18' prior: 50640450!
importAddressIfTheRecordIsOfTheCorrectLenght

	|dataToImport|
			dataToImport  := self  proccessImportData  . 
			 (dataToImport  size = 6 ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
				self importAddress: dataToImport  ]! !

!methodRemoval: CustomerImporter class #notEnoughDataInCustomerToImport stamp: 'JB 6/28/2023 17:37:18'!
notEnoughDataInCustomerToImport
	^'The customer data wasnt suficient to be imported in the data base' !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:37:34' prior: 50640327!
test07	self  should:  [
		CustomerImporter valueFrom:  (ReadStream  on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001' )  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:37:36'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:37:36'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:37:37'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:37:37'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:37:37'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:37:37'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:37:37'!
ERROR!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:37:38'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:37:38'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:37:52' prior: 50640254!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:37:54'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:37:57'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:37:57'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:37:58'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:37:58'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:37:58'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:37:58'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:37:58'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:37:59'!
PASSED!

!methodRemoval: CustomerImporter class #notEnoughDataInAddressToImport stamp: 'JB 6/28/2023 17:38:22'!
notEnoughDataInAddressToImport
	^'The data Adrress wasnt  suficient to import' !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 17:38:29' prior: 50640462!
notEnoughDataToImport
	^'The  data wasnt suficient to be imported in the data base' ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:38:32'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:38:32'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:38:32'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:38:32'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:38:32'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:38:33'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:38:33'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:39:14' prior: 50640481!
importAddressIfTheRecordIsOfTheCorrectLenght

	|dataToImport|
			dataToImport  := self  proccessImportData  . 
			 (dataToImport  size = 6 ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
				^self importAddress: dataToImport  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:39:17' prior: 50640624!
importAddressIfTheRecordIsOfTheCorrectLenght

	|dataToImport|
			dataToImport  := self  proccessImportData  . 
			 (dataToImport  size = 6 ) ifFalse:[
				^self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
				^self importAddress: dataToImport  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:39:29' prior: 50640636!
importAddressIfTheRecordIsOfTheCorrectLenght

	|dataToImport|
			dataToImport  := self  proccessImportData  . 
			 (dataToImport  size = 6 ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
				self importAddress: dataToImport  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:41:30'!
xxx:  dataToImport expectedSize: anExpectedSizeNumber do: aBlockCollaborationWithData



			 (dataToImport  size = anExpectedSizeNumber ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
		aBlockCollaborationWithData value : dataToImport  ]! !
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:42:34' prior: 50640469!
importDataIfTheRecordIsOfTheCorrectLenght

	|dataToImport| 
		dataToImport:= self proccessImportData. 
		self xxx:  dataToImport  expectedSize:   5 do: [:customerData|
			self  importCustomer:  customerData  
			] ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:42:36'!
ERROR!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:42:36'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:42:36'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:42:36'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:42:36'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:42:36'!
FAILURE!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:42:36'!
FAILURE!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:37:18' prior: 50640671!
importDataIfTheRecordIsOfTheCorrectLenght

	|dataToImport| 
		dataToImport:= self proccessImportData. 
		 (dataToImport  size = 5 )ifFalse: [
				self error: self class notEnoughDataToImport 
			]ifTrue:  [
				 self importCustomer:  dataToImport  ]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:43:56'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:43:56'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:43:56'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:43:56'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:43:57'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:43:57'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:43:57'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:45:04' prior: 50640704!
importDataIfTheRecordIsOfTheCorrectLenght

			self  xxx:  self  proccessImportData  expectedSize: 5   do: 
			[:customerData |
				 self importCustomer:  customerData 
				]
			! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:45:05'!
ERROR!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:45:05'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:45:05'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:45:06'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:45:06'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:45:06'!
FAILURE!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:45:06'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:45:09'!
ERROR!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:45:33' prior: 50640659!
xxx:  dataToImport expectedSize: anExpectedSizeNumber do: aBlockCollaborationWithData



			 (dataToImport  size = anExpectedSizeNumber ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
		aBlockCollaborationWithData value: dataToImport  ]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:45:35'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:45:35'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:45:36'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:45:36'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:45:36'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:45:36'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:45:36'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:46:25' prior: 50640648!
importAddressIfTheRecordIsOfTheCorrectLenght

	self xxx:  self proccessImportData  expectedSize:   6 do:[:addressData |
		self  importAddress:  addressData 
		] ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:46:27'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:46:27'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:46:27'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:46:27'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:46:28'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:46:28'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:46:28'!
PASSED!
!CustomerImporter methodsFor: 'import-private' stamp: 'JB 6/28/2023 17:47:13'!
checkIfTheData:  dataToImport isOfTHeExpectedSize: anExpectedSizeNumber andExecute: aBlockCollaborationWithData



			 (dataToImport  size = anExpectedSizeNumber ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
		aBlockCollaborationWithData value: dataToImport  ]! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 17:47:13' prior: 50640738!
importDataIfTheRecordIsOfTheCorrectLenght

			self  checkIfTheData:  self  proccessImportData  isOfTHeExpectedSize: 5   andExecute: 
			[:customerData |
				 self importCustomer:  customerData 
				]
			! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 17:47:13' prior: 50640807!
importAddressIfTheRecordIsOfTheCorrectLenght

	self checkIfTheData:  self proccessImportData  isOfTHeExpectedSize:   6 andExecute:[:addressData |
		self  importAddress:  addressData 
		] ! !

!methodRemoval: CustomerImporter #xxx:expectedSize:do: stamp: 'JB 6/28/2023 17:47:13'!
xxx:  dataToImport expectedSize: anExpectedSizeNumber do: aBlockCollaborationWithData



			 (dataToImport  size = anExpectedSizeNumber ) ifFalse:[
				self error: self class notEnoughDataToImport 
				]
				 ifTrue:[
		
		aBlockCollaborationWithData value: dataToImport  ]!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:47:21'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:47:21'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:47:21'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:47:21'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:47:22'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:47:22'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:47:22'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:48:06'!
invalidDatawrongSizedAddress

	^ ReadStream  on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:48:06' prior: 50640499!
test07	self  should:  [
		CustomerImporter valueFrom:  (self invalidDatawrongSizedAddress )  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:48:16' prior: 50640912!
test07	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:48:29' prior: 50640925!
test07	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
						
		] 







! !
!ImportTest methodsFor: 'assertions' stamp: 'JB 6/28/2023 17:50:05'!
assertJuanPerezWasImported

	^ self assertCustomerWithIdentificationType: 'C' number: '23-25666777-9' hasFirstName: 'Juan' lastName: 'Perez'! !
!ImportTest methodsFor: 'assertions' stamp: 'JB 6/28/2023 17:50:05' prior: 50637867!
assertJuanPerezWasImportedCorrectly

	| importedCustomer |

	importedCustomer := self assertJuanPerezWasImported.
	self assertAddressOf: importedCustomer at: 'Alem' hasNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA'
	! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:50:08'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:50:08'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:50:08'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:50:08'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:50:09'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:50:09'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:50:09'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:50:25' prior: 50640938!
test07	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
						
		] 







! !

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:50:26'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:50:27'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:50:27'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:50:28'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:50:28'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:50:28'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:50:28'!
PASSED!

!testRun: #ImportTest #test07 stamp: 'JB 6/28/2023 17:50:29'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:50:35' prior: 50640992!
test07	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:51:01'!
test07importDataWithWrongSizedAddressShouldRaiseAnError	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







! !

!methodRemoval: ImportTest #test07 stamp: 'JB 6/28/2023 17:51:01'!
test07	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 17:51:03'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 17:51:03'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 17:51:04'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 17:51:04'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 17:51:04'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 17:51:04'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 17:51:04'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 17:51:05'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:51:12'!
test08	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:58:45' prior: 50641101!
test08	self  should:  [
		CustomerImporter valueFrom: (ReadStream on: 'X,Pepe,Sanchez,D,22333444' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:59:42' prior: 50641115!
test08	self  should:  [
		CustomerImporter valueFrom: (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
X,Juan,Perez,C,23-25666777-9' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:59:50' prior: 50641130!
test08	self  should:  [
		CustomerImporter valueFrom: (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
X,Juan,Perez,C,23-25666777-9' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				
				
						
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 17:59:58' prior: 50641148!
test08	self  should:  [
		CustomerImporter valueFrom: (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
X,Juan,Perez,C,23-25666777-9' ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 17:59:59'!
FAILURE!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:04:26' prior: 50638950!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport  )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:04:29'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:04:29'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:04:29'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:04:29'!
ERROR!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:04:29'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:04:30'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:04:30'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:04:31'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:04:41'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:04:41'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:04:41'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:04:42'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:04:42'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:04:42'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:04:43'!
ERROR!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:04:43'!
ERROR!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:04:45'!
ERROR!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 18:04:51'!
inputTypeNotSupported
	self shouldBeImplemented.! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 18:05:05' prior: 50641249!
inputTypeNotSupported
	^'wrong input type' ! !

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:05:06'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:05:28'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:05:29'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:05:29'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:05:29'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:05:29'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:05:30'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:05:30'!
ERROR!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:05:30'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:05:30'!
ERROR!

'' beginsWith:  'A'!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:10:04' prior: 50641184!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line isEmpty ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:10:07'!
ERROR!

line isEmpty !

line!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:11:42' prior: 50641291!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line = String  crString  ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:11:45'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:11:45'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:11:45'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:11:45'!
ERROR!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:11:46'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:11:46'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:11:46'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:11:47'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:11:47'!
ERROR!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:11:52'!
ERROR!

line!

self = String  crString !

self = String  crlfString!

self = '
'!

self = ' '!

self = '	'!

self = ''!

self = ' '!

self =  $	"09"!

$	"09"!

'' isString !

self isString !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:16:51' prior: 50641307!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line size > 1   ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:16:52'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:16:53'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:16:53'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:16:53'!
ERROR!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:16:53'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:16:53'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:16:54'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:16:54'!
FAILURE!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:17:12' prior: 50641358!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line size = 1   ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:17:14'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:17:14'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:17:14'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:17:14'!
ERROR!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:17:14'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:17:14'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:17:15'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:17:15'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:17:16'!
ERROR!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:17:43'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:17:47'!
ERROR!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:17:47'!
ERROR!

line size!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:18:44'!
ERROR!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:18:44'!
ERROR!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:19:23'!
ERROR!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:19:23'!
ERROR!

line size = 1 !

line size!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:19:53' prior: 50641396!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line size = 0   ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:19:57'!
ERROR!

line!

self size!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:20:17' prior: 50641462!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line size = 1   ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:20:18'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:20:19'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:20:19'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:20:20'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:20:20'!
ERROR!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:20:20'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:20:20'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:20:20'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:20:21'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:20:21'!
ERROR!

line!

line size = 1 !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:20:57' prior: 50641478!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or:(line size = 1  or: (line size = 0 )) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:20:58'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:21:00'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:21:01'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:21:01'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:21:01'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:21:01'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:21:02'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:21:02'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:21:02'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:21:03'!
PASSED!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:22:25' prior: 50641524!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or: (line size = 1  or: (line size = 0 ) ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:22:41'!
isEmptyLine

	^ line size = 1  or: (line size = 0 )! !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:22:42' prior: 50641570!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	(self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or: (self isEmptyLine ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:23:22'!
checkForInvalidInputType

	^ (self thereIsACustomerToImport  or: (self  thereIsAnAddressToImport or: (self isEmptyLine ) )) ifFalse:  [
		self error: self class  inputTypeNotSupported
		]! !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:23:22' prior: 50641587!
importRecord

	self importANewCustomerIfItsACustomerRecord.	self importNewAddressIfItsAnAddressRecord.
	self checkForInvalidInputType! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:23:43'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:23:43'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:23:43'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:23:43'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:23:43'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:23:44'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:23:44'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:23:45'!
PASSED!

self at: 1!

self at: 0!

self at:1 !

String with: $	"09" !

self =   String with: $	"09" !

String with: $	"09"!

self =  (String with: $	"09")!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:30:11' prior: 50641582!
isEmptyLine

	^( line = (String with: $	"09")) or: (line isEmpty )! !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:30:30'!
isReturnCarriegeString

	^ line = (String with: $	"09")! !
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:30:30' prior: 50641645!
isEmptyLine

	^( self isReturnCarriegeString) or: (line isEmpty )! !

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:30:34'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:30:36'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:30:37'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:30:37'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:30:37'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:30:37'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:30:37'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:30:38'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:30:38'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:30:39'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:31:07'!
invalidDataWrongType

	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
X,Juan,Perez,C,23-25666777-9'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:31:07' prior: 50641165!
test08	self  should:  [
		CustomerImporter valueFrom: (self invalidDataWrongType ) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:31:14' prior: 50641701!
test08	self  should:  [
		CustomerImporter valueFrom: self invalidDataWrongType  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:31:16'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:31:16'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:31:17'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:31:17'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:31:17'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:31:17'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:31:17'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:31:18'!
PASSED!

!testRun: #ImportTest #test08 stamp: 'JB 6/28/2023 18:31:18'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:31:40'!
test08importDataWithInvalidDataTypeShouldRaiseAnError	self  should:  [
		CustomerImporter valueFrom: self invalidDataWrongType  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !

!methodRemoval: ImportTest #test08 stamp: 'JB 6/28/2023 18:31:40'!
test08	self  should:  [
		CustomerImporter valueFrom: self invalidDataWrongType  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:31:47'!
test09 	self  should:  [
		CustomerImporter valueFrom: self invalidDataWrongType  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  inputTypeNotSupported  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:38:21' prior: 50641779!
test09 	self  should:  [
		CustomerImporter valueFrom: (ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,xxx,CABA,1001,CABA') into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:38:24'!
ERROR!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 18:38:30'!
invalidInput
	self shouldBeImplemented.! !
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 18:38:51' prior: 50641812!
invalidInput
	^'input not suported' ! !

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:38:52'!
FAILURE!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:40:16' prior: 50638828!
importAddress: addressData

	|  newAddress |
			
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			[newAddress streetNumber: addressData third asNumber]on:  Error
			
			 do:[self error:  self class invalidInput ].
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:40:19'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:40:19'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:40:20'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:40:20'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:20'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:20'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:21'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:21'!
PASSED!

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:40:22'!
PASSED!
!CustomerImporter methodsFor: 'import' stamp: 'JB 6/28/2023 18:40:50' prior: 50641824!
importAddress: addressData

	|  newAddress |
			
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			[newAddress streetNumber: addressData third asNumber.
				newAddress zipCode: addressData fifth asNumber
				]on:  Error
			
			 do:[self error:  self class invalidInput ].
			newAddress town: addressData fourth.
			 
			newAddress province: addressData sixth! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:40:53'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:40:53'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:40:53'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:40:53'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:54'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:54'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:54'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:40:55'!
PASSED!

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:40:55'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:41:26' prior: 50641792!
test09 	self  should:  [
		CustomerImporter valueFrom: (ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,xxx,CABA') into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:41:28'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:41:29'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:41:30'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:41:30'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:41:30'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:30'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:30'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:31'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:31'!
PASSED!

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:41:32'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:38:21' prior: 50641917!
test09 	self  should:  [
		CustomerImporter valueFrom: (ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,xxx,CABA,1001,CABA') into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:41:46'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:41:47'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:41:48'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:41:48'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:41:48'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:48'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:48'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:49'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:41:49'!
PASSED!

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:41:50'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:41:54'!
test10	self  should:  [
		CustomerImporter valueFrom: (ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,xxx,CABA,1001,CABA') into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:41:58' prior: 50642017!
test10	self  should:  [
		CustomerImporter valueFrom: (ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA') into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:42:02' prior: 50642035!
test10	self  should:  [
		CustomerImporter valueFrom: (ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,xxx,CABA') into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!testRun: #ImportTest #test10 stamp: 'JB 6/28/2023 18:42:03'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:42:04'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:42:04'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:42:05'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:42:05'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:42:05'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:42:05'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:42:06'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:42:06'!
PASSED!

!testRun: #ImportTest #test09 stamp: 'JB 6/28/2023 18:42:07'!
PASSED!

!testRun: #ImportTest #test10 stamp: 'JB 6/28/2023 18:42:07'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:42:27'!
invalidInputBadAddressNumber

	^ ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,xxx,CABA,1001,CABA'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:42:27' prior: 50641967!
test09 	self  should:  [
		CustomerImporter valueFrom: (self invalidInputBadAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:42:46'!
invalidInputWrongZipCode

	^ ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,xxx,CABA'! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:42:47' prior: 50642053!
test10	self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongZipCode) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:43:03'!
invalidInputWrongAddressNumber

	^ ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,xxx,CABA,1001,CABA'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:43:03' prior: 50642115!
test09 	self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!methodRemoval: ImportTest #invalidInputBadAddressNumber stamp: 'JB 6/28/2023 18:43:03'!
invalidInputBadAddressNumber

	^ ReadStream  on:		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,xxx,CABA,1001,CABA'!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:43:39'!
test09importDataWithWrongAddressNumberShouldRaisAnError 	self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!methodRemoval: ImportTest #test09 stamp: 'JB 6/28/2023 18:43:39'!
test09 	self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:44:08'!
test10importDataWithWrongZipCodeAddressShouldRaiseAnError	self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongZipCode) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







! !

!methodRemoval: ImportTest #test10 stamp: 'JB 6/28/2023 18:44:08'!
test10	self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongZipCode) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		] 







!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:52:14'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:52:14' prior: 50642183!
test09importDataWithWrongAddressNumberShouldRaisAnError 	self xxx 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:53:05'!
xxx: aInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:53:05' prior: 50642251!
test09importDataWithWrongAddressNumberShouldRaisAnError 	self xxx: self invalidInputWrongAddressNumber 







! !

!methodRemoval: ImportTest #xxx stamp: 'JB 6/28/2023 18:53:05'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom: (self invalidInputWrongAddressNumber) into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:53:36' prior: 50642256!
xxx: aInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: aInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:53:40' prior: 50642290!
xxx: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: anInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidInput equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:53:43'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:53:43'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:53:43'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:53:43'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:53:44'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:53:44'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:53:44'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:53:45'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 18:53:45'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:53:46'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:54:14' prior: 50642211!
test10importDataWithWrongZipCodeAddressShouldRaiseAnError		self xxx:  self invalidInputWrongZipCode






! !

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:54:16'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:54:18'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:54:19'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:54:19'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:54:19'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:54:19'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:54:19'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:54:20'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:54:20'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 18:54:21'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:54:21'!
PASSED!
!CustomerImporter class methodsFor: 'error message' stamp: 'JB 6/28/2023 18:55:43'!
invalidAddressFields
	^'input not suported' ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:55:43' prior: 50642304!
xxx: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: anInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidAddressFields equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:55:43' prior: 50641870!
importAddress: addressData

	|  newAddress |
			
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			[newAddress streetNumber: addressData third asNumber.
				newAddress zipCode: addressData fifth asNumber
				]on:  Error
			
			 do:[self error:  self class invalidAddressFields ].
			newAddress town: addressData fourth.
			 
			newAddress province: addressData sixth! !

!methodRemoval: CustomerImporter class #invalidInput stamp: 'JB 6/28/2023 18:55:43'!
invalidInput
	^'input not suported' !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 18:56:06'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 18:56:06'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 18:56:07'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 18:56:07'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 18:56:07'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 18:56:07'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:56:08'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 18:56:08'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 18:56:09'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 18:56:09'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:57:38'!
assertRaisesAnErrorAndImportPepeSanchezAndJuanPerezWhitInvalidAddressFieldInput: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: anInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidAddressFields equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:57:38' prior: 50642271!
test09importDataWithWrongAddressNumberShouldRaisAnError 	self assertRaisesAnErrorAndImportPepeSanchezAndJuanPerezWhitInvalidAddressFieldInput: self invalidInputWrongAddressNumber 







! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:57:38' prior: 50642353!
test10importDataWithWrongZipCodeAddressShouldRaiseAnError		self assertRaisesAnErrorAndImportPepeSanchezAndJuanPerezWhitInvalidAddressFieldInput:  self invalidInputWrongZipCode






! !

!methodRemoval: ImportTest #xxx: stamp: 'JB 6/28/2023 18:57:38'!
xxx: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: anInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidAddressFields equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 18:59:22'!
assertThatImportsUntilInvalidAddressFieldAndRaisesAnError: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: anInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidAddressFields equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:59:22' prior: 50642490!
test09importDataWithWrongAddressNumberShouldRaisAnError 	self assertThatImportsUntilInvalidAddressFieldAndRaisesAnError: self invalidInputWrongAddressNumber 







! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 18:59:22' prior: 50642499!
test10importDataWithWrongZipCodeAddressShouldRaiseAnError		self assertThatImportsUntilInvalidAddressFieldAndRaisesAnError:  self invalidInputWrongZipCode






! !

!methodRemoval: ImportTest #assertRaisesAnErrorAndImportPepeSanchezAndJuanPerezWhitInvalidAddressFieldInput: stamp: 'JB 6/28/2023 18:59:22'!
assertRaisesAnErrorAndImportPepeSanchezAndJuanPerezWhitInvalidAddressFieldInput: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom: anInvalidInputStream into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter   invalidAddressFields equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.
				self assertJuanPerezWasImported . 		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:00:41'!
xxx	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







! !

!methodRemoval: ImportTest #xxx stamp: 'JB 6/28/2023 19:00:52'!
xxx	self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		] 







!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:01:00'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:01:00' prior: 50641045!
test07importDataWithWrongSizedAddressShouldRaiseAnError	self xxx 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:01:48'!
xxx: invalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:01:48' prior: 50642611!
test07importDataWithWrongSizedAddressShouldRaiseAnError	self xxx: self invalidDatawrongSizedAddress 







! !

!methodRemoval: ImportTest #xxx stamp: 'JB 6/28/2023 19:01:48'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:02:34'!
xxx: invalidInputStream raisesAnErrorWithMessage: messageError 

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:02:34' prior: 50642631!
test07importDataWithWrongSizedAddressShouldRaiseAnError	self xxx: self invalidDatawrongSizedAddress raisesAnErrorWithMessage: CustomerImporter  notEnoughDataToImport 







! !

!methodRemoval: ImportTest #xxx: stamp: 'JB 6/28/2023 19:02:34'!
xxx: invalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDatawrongSizedAddress into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:02:47' prior: 50642650!
xxx: invalidInputStream raisesAnErrorWithMessage: messageError 

	^ self  should:  [
		CustomerImporter valueFrom:  invalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: messageError equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:02:49'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:02:50'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:02:50'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:02:50'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:02:50'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:02:50'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:02:51'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:02:51'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:02:52'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:02:52'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:04:00'!
assertImportsUntilAnErrorAppearsWithTheInputStream: invalidInputStream raisesAnErrorWithMessage: messageError 

	^ self  should:  [
		CustomerImporter valueFrom:  invalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: messageError equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:04:00' prior: 50642666!
test07importDataWithWrongSizedAddressShouldRaiseAnError	self assertImportsUntilAnErrorAppearsWithTheInputStream: self invalidDatawrongSizedAddress raisesAnErrorWithMessage: CustomerImporter  notEnoughDataToImport 







! !

!methodRemoval: ImportTest #xxx:raisesAnErrorWithMessage: stamp: 'JB 6/28/2023 19:04:00'!
xxx: invalidInputStream raisesAnErrorWithMessage: messageError 

	^ self  should:  [
		CustomerImporter valueFrom:  invalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: messageError equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .
				
						
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:04:31' prior: 50642520!
assertThatImportsUntilInvalidAddressFieldAndRaisesAnError: anInvalidInputStream

	^ self  assertImportsUntilAnErrorAppearsWithTheInputStream:  anInvalidInputStream  raisesAnErrorWithMessage: ' ' ! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:04:52' prior: 50642777!
assertThatImportsUntilInvalidAddressFieldAndRaisesAnError: anInvalidInputStream

	^ self  assertImportsUntilAnErrorAppearsWithTheInputStream:  anInvalidInputStream  raisesAnErrorWithMessage: CustomerImporter   invalidAddressFields! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:04:53'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:04:54'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:04:54'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:04:54'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:04:54'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:04:54'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:04:55'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:04:55'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:04:56'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:04:57'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:05:47'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:05:47' prior: 50640545!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self xxx 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:06:12'!
xxx: anInvalidStream

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:06:12' prior: 50642844!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self xxx: self invalidDataWrongSizeCustomer 







! !

!methodRemoval: ImportTest #xxx stamp: 'JB 6/28/2023 19:06:12'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom:  self invalidDataWrongSizeCustomer  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:06:19' prior: 50642849!
xxx: anInvalidStream

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:06:20'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:06:21'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:06:21'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:06:21'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:06:21'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:06:21'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:06:22'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:06:22'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:06:23'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:06:23'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:07:14'!
xxx: anInvalidStream raisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:07:14' prior: 50642862!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self xxx: self invalidDataWrongSizeCustomer raisesAnErrorWithMessage: CustomerImporter  notEnoughDataToImport 







! !

!methodRemoval: ImportTest #xxx: stamp: 'JB 6/28/2023 19:07:14'!
xxx: anInvalidStream

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  notEnoughDataToImport  equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:07:17'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:07:17'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:07:18'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:07:18'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:18'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:18'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:19'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:19'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:07:20'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:20'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:07:29' prior: 50642927!
xxx: anInvalidStream raisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:07:31'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:07:31'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:07:31'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:07:31'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:31'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:32'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:32'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:33'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:07:33'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:07:34'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:08:28'!
assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: anInvalidStream theRaisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:08:28' prior: 50642941!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: self invalidDataWrongSizeCustomer theRaisesAnErrorWithMessage: CustomerImporter  notEnoughDataToImport 







! !

!methodRemoval: ImportTest #xxx:raisesAnErrorWithMessage: stamp: 'JB 6/28/2023 19:08:28'!
xxx: anInvalidStream raisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:09:10' prior: 50641754!
test08importDataWithInvalidDataTypeShouldRaiseAnError	
	
	self assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream:  self invalidDataWrongType    theRaisesAnErrorWithMessage: CustomerImporter  inputTypeNotSupported







! !

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:09:11'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:09:12'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:09:13'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:09:13'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:09:13'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:09:13'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:09:13'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:09:14'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:09:14'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:09:15'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:09:16'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:09:28'!
assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: anInvalidStream thenRaisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:09:28' prior: 50643060!
test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError	self assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: self invalidDataWrongSizeCustomer thenRaisesAnErrorWithMessage: CustomerImporter  notEnoughDataToImport 







! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:09:28' prior: 50643084!
test08importDataWithInvalidDataTypeShouldRaiseAnError	
	
	self assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream:  self invalidDataWrongType    thenRaisesAnErrorWithMessage: CustomerImporter  inputTypeNotSupported







! !

!methodRemoval: ImportTest #assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream:theRaisesAnErrorWithMessage: stamp: 'JB 6/28/2023 19:09:28'!
assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: anInvalidStream theRaisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				 self assertPepeSanchezWasImportedCorrecty.  		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:09:46'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:09:47' prior: 50639842!
test05importAnAddressBeforACustomerShouldRaiseAnError	self xxx 







! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:10:18'!
xxx: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:10:18' prior: 50643199!
test05importAnAddressBeforACustomerShouldRaiseAnError	self xxx: self importDataOnlyAnAdress 







! !

!methodRemoval: ImportTest #xxx stamp: 'JB 6/28/2023 19:10:18'!
xxx

	^ self  should:  [
		CustomerImporter valueFrom:  self importDataOnlyAnAdress  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:10:25' prior: 50643204!
xxx: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:10:59'!
xxx: anInvalidInputStream raisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:10:59' prior: 50643218!
test05importAnAddressBeforACustomerShouldRaiseAnError	self xxx: self importDataOnlyAnAdress raisesAnErrorWithMessage: CustomerImporter  cannotImportAddressWithoutCustomer 







! !

!methodRemoval: ImportTest #xxx: stamp: 'JB 6/28/2023 19:10:59'!
xxx: anInvalidInputStream

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: CustomerImporter  cannotImportAddressWithoutCustomer  equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:11:08' prior: 50643248!
xxx: anInvalidInputStream raisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:11:48' prior: 50639205!
test02importWithNilDataRaisesAnError
self xxx:self nilImportData   raisesAnErrorWithMessage: CustomerImporter  nilStreamErrorMessage 

! !

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:11:49'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:11:50'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:11:50'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:11:50'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:11:50'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:11:50'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:11:50'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:11:51'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:11:52'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:11:52'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:11:53'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:12:36'!
assertSessionIsNotModifyByImporting: anInvalidInputStream andRaisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:12:36' prior: 50643263!
test05importAnAddressBeforACustomerShouldRaiseAnError	self assertSessionIsNotModifyByImporting: self importDataOnlyAnAdress andRaisesAnErrorWithMessage: CustomerImporter  cannotImportAddressWithoutCustomer 







! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'JB 6/28/2023 19:12:36' prior: 50643297!
test02importWithNilDataRaisesAnError
self assertSessionIsNotModifyByImporting:self nilImportData   andRaisesAnErrorWithMessage: CustomerImporter  nilStreamErrorMessage 

! !

!methodRemoval: ImportTest #xxx:raisesAnErrorWithMessage: stamp: 'JB 6/28/2023 19:12:36'!
xxx: anInvalidInputStream raisesAnErrorWithMessage: anErrorMessage 

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				self assert:  self isSessionEmpty  .  		
		]!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:13:42' prior: 50643342!
assertSessionIsNotModifyByImporting: anInvalidInputStream andRaisesAnErrorWithMessage: anErrorMessage 
	|aBlock |
	aBlock := [self assert:  self isSessionEmpty  .  		].
	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				aBlock  value.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:14:44'!
assertThatImportingTheInvalidStream: anInvalidInputStream ensures: anErrorMessage andRaisesAnErrorWithMessage: aBlock

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				aBlock  value.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:14:45' prior: 50643388!
assertSessionIsNotModifyByImporting: anInvalidInputStream andRaisesAnErrorWithMessage: anErrorMessage 
	|aBlock |
	aBlock := [self assert:  self isSessionEmpty  .  		].
	^ self assertThatImportingTheInvalidStream: anInvalidInputStream ensures: anErrorMessage andRaisesAnErrorWithMessage: aBlock! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:14:54' prior: 50643417!
assertSessionIsNotModifyByImporting: anInvalidInputStream andRaisesAnErrorWithMessage: anErrorMessage 
	^ self assertThatImportingTheInvalidStream: anInvalidInputStream ensures: anErrorMessage andRaisesAnErrorWithMessage: [self assert:  self isSessionEmpty  .  		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:14:58'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:14:58'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:14:59'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:14:59'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:14:59'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:14:59'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:15:00'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:15:00'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:15:01'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:15:01'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:16:27' prior: 50643133!
assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: anInvalidStream thenRaisesAnErrorWithMessage: anErrorMessage 

	self assertThatImportingTheInvalidStream:  anInvalidStream  ensures: [ self assertPepeSanchezWasImportedCorrecty.  		 ]  andRaisesAnErrorWithMessage: anErrorMessage ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:16:29'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:16:29'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:16:30'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:16:30'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:30'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:30'!
FAILURE!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:30'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:31'!
FAILURE!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:16:31'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:32'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:16:41' prior: 50643476!
assertPepeSanchezWasImportedCorrectlyWithTheInvalidInputStream: anInvalidStream thenRaisesAnErrorWithMessage: anErrorMessage 

	^self assertThatImportingTheInvalidStream:  anInvalidStream  ensures: [ self assertPepeSanchezWasImportedCorrecty.  		 ]  andRaisesAnErrorWithMessage: anErrorMessage ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:16:43'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:16:43'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:16:43'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:16:43'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:43'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:43'!
FAILURE!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:44'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:44'!
FAILURE!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:16:45'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:16:46'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:16:59'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:16:59'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:16:59'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:16:59'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:17:00'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:17:00'!
FAILURE!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:17:00'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:17:01'!
FAILURE!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:17:01'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:17:02'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:17:45' prior: 50643403!
assertThatImportingTheInvalidStream: anInvalidInputStream ensures: aBlockAux andRaisesAnErrorWithMessage: aBlock

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: aBlockAux equals: anError messageText. 
				aBlock  value.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:18:05' prior: 50643607!
assertThatImportingTheInvalidStream: anInvalidInputStream ensures: aBlockToEnsure andRaisesAnErrorWithMessage: aBlock

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: aBlockToEnsure equals: anError messageText. 
				aBlock  value.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:18:23' prior: 50643621!
assertThatImportingTheInvalidStream: anInvalidInputStream ensures: aBlockToEnsure andRaisesAnErrorWithMessage: anErrorMessage

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: aBlockToEnsure equals: anError messageText. 
				anErrorMessage  value.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:18:37' prior: 50643635!
assertThatImportingTheInvalidStream: anInvalidInputStream ensures: aBlockToEnsure andRaisesAnErrorWithMessage: anErrorMessage

	^ self  should:  [
		CustomerImporter valueFrom:  anInvalidInputStream  into: session. 				
		] raise: Error
	  withExceptionDo:[:anError|
				self assert: anErrorMessage equals: anError messageText. 
				aBlockToEnsure  value.
		]! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:18:38'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:18:39'!
FAILURE!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:18:39'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:18:39'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:18:39'!
FAILURE!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:18:39'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:18:40'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:18:40'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:18:41'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:18:42'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:18:56' prior: 50643367!
test02importWithNilDataRaisesAnError
self assertSessionIsNotModifyByImporting: self nilImportData   andRaisesAnErrorWithMessage: CustomerImporter  nilStreamErrorMessage 

! !

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:19:08'!
FAILURE!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:19:57'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:20:39' prior: 50643429!
assertSessionIsNotModifyByImporting: anInvalidInputStream andRaisesAnErrorWithMessage: anErrorMessage 
	^ self assertThatImportingTheInvalidStream: anInvalidInputStream ensures: [self assert:  self isSessionEmpty  .  		] andRaisesAnErrorWithMessage: anErrorMessage! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:20:43'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:20:44'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:20:44'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:20:44'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:20:44'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:20:44'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:20:45'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:20:45'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:20:46'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:20:46'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:22:33' prior: 50642737!
assertImportsUntilAnErrorAppearsWithTheInputStream: invalidInputStream raisesAnErrorWithMessage: messageError 

	self assertThatImportingTheInvalidStream: invalidInputStream   ensures: [ self assertPepeSanchezWasImportedCorrecty.  
				self assertJuanPerezWasImported .] andRaisesAnErrorWithMessage: messageError ! !

!testRun: #ImportTest #test01Import stamp: 'JB 6/28/2023 19:22:35'!
PASSED!

!testRun: #ImportTest #test02importWithNilDataRaisesAnError stamp: 'JB 6/28/2023 19:22:36'!
PASSED!

!testRun: #ImportTest #test03importEmptyDataShouldNotModifySession stamp: 'JB 6/28/2023 19:22:36'!
PASSED!

!testRun: #ImportTest #test04importDataWithALineJumpShouldNotModifySession stamp: 'JB 6/28/2023 19:22:36'!
PASSED!

!testRun: #ImportTest #test05importAnAddressBeforACustomerShouldRaiseAnError stamp: 'JB 6/28/2023 19:22:36'!
PASSED!

!testRun: #ImportTest #test06importDataWithWrongSizedCustomerRecordShouldRaiseAnError stamp: 'JB 6/28/2023 19:22:36'!
PASSED!

!testRun: #ImportTest #test07importDataWithWrongSizedAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:22:37'!
PASSED!

!testRun: #ImportTest #test08importDataWithInvalidDataTypeShouldRaiseAnError stamp: 'JB 6/28/2023 19:22:37'!
PASSED!

!testRun: #ImportTest #test09importDataWithWrongAddressNumberShouldRaisAnError stamp: 'JB 6/28/2023 19:22:38'!
PASSED!

!testRun: #ImportTest #test10importDataWithWrongZipCodeAddressShouldRaiseAnError stamp: 'JB 6/28/2023 19:22:39'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:24:12'!
test01aValidInputStreamImportsIntoTheSessionCorrectly

	CustomerImporter valueFrom: self validImportData into: session..

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!methodRemoval: ImportTest #test01Import stamp: 'JB 6/28/2023 19:24:12'!
test01Import

	CustomerImporter valueFrom: self validImportData into: session..

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly !
!ImportTest methodsFor: 'tests' stamp: 'JB 6/28/2023 19:25:26'!
test01aValidInputStreamIsImportedCorrectlyToTheSession

	CustomerImporter valueFrom: self validImportData into: session..

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!methodRemoval: ImportTest #test01aValidInputStreamImportsIntoTheSessionCorrectly stamp: 'JB 6/28/2023 19:25:26'!
test01aValidInputStreamImportsIntoTheSessionCorrectly

	CustomerImporter valueFrom: self validImportData into: session..

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly !